<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MQCPack: mqc_algebra Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="mqcpack_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MQCPack
   </div>
   <div id="projectbrief">MQCPack: The Merced Quantum Chemistry Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemqc__algebra.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">mqc_algebra Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><b> MQC Algebra contains mathematical objects that are designed to simplify and automate variable use in Fortran </b>  
<a href="namespacemqc__algebra.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1abs.html">abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Takes the absolute value</b>  <a href="interfacemqc__algebra_1_1abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1acos.html">acos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the arccosine</b>  <a href="interfacemqc__algebra_1_1acos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1aimag.html">aimag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the imaginary part</b>  <a href="interfacemqc__algebra_1_1aimag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1asin.html">asin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the arcsine</b>  <a href="interfacemqc__algebra_1_1asin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1assignment_07_0a_08.html">assignment(=)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Assigns a variable to the value of another</b>  <a href="interfacemqc__algebra_1_1assignment_07_0a_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1atan.html">atan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the arctangent</b>  <a href="interfacemqc__algebra_1_1atan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1atan2.html">atan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the arctangent accounting for circle quadrant</b>  <a href="interfacemqc__algebra_1_1atan2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1cmplx.html">cmplx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Defines a complex number</b>  <a href="interfacemqc__algebra_1_1cmplx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1conjg.html">conjg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the complex conjugate</b>  <a href="interfacemqc__algebra_1_1conjg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1contraction.html">contraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Contracts two arrays</b>  <a href="interfacemqc__algebra_1_1contraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1cos.html">cos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the cosine</b>  <a href="interfacemqc__algebra_1_1cos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1dagger.html">dagger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the Hermitian conjugate</b>  <a href="interfacemqc__algebra_1_1dagger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1dot__product.html">dot_product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the dot product</b>  <a href="interfacemqc__algebra_1_1dot__product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1matmul.html">matmul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Multiplies two arrays</b>  <a href="interfacemqc__algebra_1_1matmul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1matrix__symm2sq.html">matrix_symm2sq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sets a symmetric packed intrinsic array as a square packed intrinsic array</b>  <a href="interfacemqc__algebra_1_1matrix__symm2sq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__cast__complex.html">mqc_cast_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sets an array to complex type</b>  <a href="interfacemqc__algebra_1_1mqc__cast__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__cast__integer.html">mqc_cast_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sets an array to integer type</b>  <a href="interfacemqc__algebra_1_1mqc__cast__integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__cast__real.html">mqc_cast_real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sets an array to real type</b>  <a href="interfacemqc__algebra_1_1mqc__cast__real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__have__complex.html">mqc_have_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines in an array is complex type</b>  <a href="interfacemqc__algebra_1_1mqc__have__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__have__int.html">mqc_have_int</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines in an array is integer type</b>  <a href="interfacemqc__algebra_1_1mqc__have__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__have__real.html">mqc_have_real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines in an array is real type</b>  <a href="interfacemqc__algebra_1_1mqc__have__real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Rank 2 array variable</b>  <a href="structmqc__algebra_1_1mqc__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__matrix__diagmatrix__put.html">mqc_matrix_diagmatrix_put</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sets a diagonal packed intinsic array as an MQC Matrix object</b>  <a href="interfacemqc__algebra_1_1mqc__matrix__diagmatrix__put.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__matrix__symmmatrix__put.html">mqc_matrix_symmmatrix_put</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sets a symmetric packed intrinsic array as an MQC Matrix object</b>  <a href="interfacemqc__algebra_1_1mqc__matrix__symmmatrix__put.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__print.html">mqc_print</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Prints an object</b>  <a href="interfacemqc__algebra_1_1mqc__print.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Updates the specified element of the MQC Matrix to the specified value</b>  <a href="structmqc__algebra_1_1mqc__r4tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Rank 0 array variable</b>  <a href="structmqc__algebra_1_1mqc__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1mqc__set__array2vector.html">mqc_set_array2vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sets an intrinsic array as an MQC Algebra object</b>  <a href="interfacemqc__algebra_1_1mqc__set__array2vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Rank 1 array variable</b>  <a href="structmqc__algebra_1_1mqc__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_5_08.html">operator(*)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Multiplies two variables</b>  <a href="interfacemqc__algebra_1_1operator_07_5_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_5_5_08.html">operator(**)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Exponentials a variable to the power of another</b>  <a href="interfacemqc__algebra_1_1operator_07_5_5_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_09_08.html">operator(+)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Sums two variables</b>  <a href="interfacemqc__algebra_1_1operator_07_09_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07-_08.html">operator(-)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Subtracts two variables</b>  <a href="interfacemqc__algebra_1_1operator_07-_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8dot_8_08.html">operator(.dot.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Computes the inner product of two arrays</b>  <a href="interfacemqc__algebra_1_1operator_07_8dot_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8eq_8_08.html">operator(.eq.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines if two variables are equal</b>  <a href="interfacemqc__algebra_1_1operator_07_8eq_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8ewd_8_08.html">operator(.ewd.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Computes the element-wise quotient of two arrays</b>  <a href="interfacemqc__algebra_1_1operator_07_8ewd_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8ewp_8_08.html">operator(.ewp.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Computes the element-wise product of two arrays</b>  <a href="interfacemqc__algebra_1_1operator_07_8ewp_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8ge_8_08.html">operator(.ge.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines if a variable is greater than or equal to another</b>  <a href="interfacemqc__algebra_1_1operator_07_8ge_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8gt_8_08.html">operator(.gt.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines if a variable is greater than another</b>  <a href="interfacemqc__algebra_1_1operator_07_8gt_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8le_8_08.html">operator(.le.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines if a variable is less than or equal to another</b>  <a href="interfacemqc__algebra_1_1operator_07_8le_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8lt_8_08.html">operator(.lt.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines if a variable is less than another</b>  <a href="interfacemqc__algebra_1_1operator_07_8lt_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8ne_8_08.html">operator(.ne.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Determines if two variables are not equal</b>  <a href="interfacemqc__algebra_1_1operator_07_8ne_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8outer_8_08.html">operator(.outer.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Computes the outer product of two vectors</b>  <a href="interfacemqc__algebra_1_1operator_07_8outer_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_8x_8_08.html">operator(.x.)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Computes the cross product of two vectors</b>  <a href="interfacemqc__algebra_1_1operator_07_8x_8_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1operator_07_2_08.html">operator(/)</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Divides two variables</b>  <a href="interfacemqc__algebra_1_1operator_07_2_08.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the real part</b>  <a href="interfacemqc__algebra_1_1real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1sin.html">sin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the sine</b>  <a href="interfacemqc__algebra_1_1sin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1sqrt.html">sqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the square root</b>  <a href="interfacemqc__algebra_1_1sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1tan.html">tan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the tangent</b>  <a href="interfacemqc__algebra_1_1tan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacemqc__algebra_1_1transpose.html">transpose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Returns the transpose</b>  <a href="interfacemqc__algebra_1_1transpose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:af43924c79b927084f5776417442fabac"><td class="memItemLeft" align="right" valign="top">integer(kind=int64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af43924c79b927084f5776417442fabac">factorial</a> (n)</td></tr>
<tr class="memdesc:af43924c79b927084f5776417442fabac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Factorial returns the factorial of an integer</b>  <a href="namespacemqc__algebra.html#af43924c79b927084f5776417442fabac">More...</a><br /></td></tr>
<tr class="separator:af43924c79b927084f5776417442fabac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8599e5948deb641a1debb6531a3ed30"><td class="memItemLeft" align="right" valign="top">integer(kind=int64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac8599e5948deb641a1debb6531a3ed30">bin_coeff</a> (N, K)</td></tr>
<tr class="memdesc:ac8599e5948deb641a1debb6531a3ed30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Bin_Coeff returns the binomial coefficient of (n,k)</b>  <a href="namespacemqc__algebra.html#ac8599e5948deb641a1debb6531a3ed30">More...</a><br /></td></tr>
<tr class="separator:ac8599e5948deb641a1debb6531a3ed30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab0b12181034281f017537a4adf730"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6fab0b12181034281f017537a4adf730">mqc_allocate_scalar</a> (Scalar, Data_type)</td></tr>
<tr class="memdesc:a6fab0b12181034281f017537a4adf730"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Allocate_Scalar is used to allocate a scalar type variable of the MQC_Scalar class</b>  <a href="namespacemqc__algebra.html#a6fab0b12181034281f017537a4adf730">More...</a><br /></td></tr>
<tr class="separator:a6fab0b12181034281f017537a4adf730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22ac4f8d222ab896734ad93e99b7ebe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae22ac4f8d222ab896734ad93e99b7ebe">mqc_deallocate_scalar</a> (Scalar)</td></tr>
<tr class="memdesc:ae22ac4f8d222ab896734ad93e99b7ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Deallocate_Scalar is used to deallocate a scalar type variable of the MQC_Scalar class</b>  <a href="namespacemqc__algebra.html#ae22ac4f8d222ab896734ad93e99b7ebe">More...</a><br /></td></tr>
<tr class="separator:ae22ac4f8d222ab896734ad93e99b7ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fad6f7ddafdd868da867c57c6b7ad4"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa9fad6f7ddafdd868da867c57c6b7ad4">mqc_scalar_isallocated</a> (Scalar)</td></tr>
<tr class="memdesc:aa9fad6f7ddafdd868da867c57c6b7ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_IsAllocated is used to determine the allocation status of an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#aa9fad6f7ddafdd868da867c57c6b7ad4">More...</a><br /></td></tr>
<tr class="separator:aa9fad6f7ddafdd868da867c57c6b7ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ff0afb694c02c897dc47299aad8fad"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac8ff0afb694c02c897dc47299aad8fad">mqc_input_integer_scalar</a> (ScalarOut, ScalarIn)</td></tr>
<tr class="memdesc:ac8ff0afb694c02c897dc47299aad8fad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Input_Integer_Scalar is a subroutine is used to set an intrinsic integer to an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ac8ff0afb694c02c897dc47299aad8fad">More...</a><br /></td></tr>
<tr class="separator:ac8ff0afb694c02c897dc47299aad8fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5523039fa283a160a967555f3983ed1d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5523039fa283a160a967555f3983ed1d">mqc_input_real_scalar</a> (ScalarOut, ScalarIn)</td></tr>
<tr class="memdesc:a5523039fa283a160a967555f3983ed1d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Input_Real_Scalar is a subroutine is used to set an intrinsic real to an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a5523039fa283a160a967555f3983ed1d">More...</a><br /></td></tr>
<tr class="separator:a5523039fa283a160a967555f3983ed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469678aed0f067aa78822a8fad2cf3be"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a469678aed0f067aa78822a8fad2cf3be">mqc_input_complex_scalar</a> (ScalarOut, ScalarIn)</td></tr>
<tr class="memdesc:a469678aed0f067aa78822a8fad2cf3be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Input_Complex_Scalar is a subroutine is used to set an intrinsic complex to an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a469678aed0f067aa78822a8fad2cf3be">More...</a><br /></td></tr>
<tr class="separator:a469678aed0f067aa78822a8fad2cf3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaea000448e874bbf904b19d76dcdd1e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#abaea000448e874bbf904b19d76dcdd1e">mqc_output_mqcscalar_scalar</a> (ScalarOut, ScalarIn)</td></tr>
<tr class="memdesc:abaea000448e874bbf904b19d76dcdd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Output MQCScalar_Scalar is a subroutine used to output an MQC_scalar equal to an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#abaea000448e874bbf904b19d76dcdd1e">More...</a><br /></td></tr>
<tr class="separator:abaea000448e874bbf904b19d76dcdd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4787b08e3af49020e71cc1e07e79c2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a1b4787b08e3af49020e71cc1e07e79c2">mqc_output_integer_scalar</a> (ScalarOut, ScalarIn)</td></tr>
<tr class="memdesc:a1b4787b08e3af49020e71cc1e07e79c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Output_Integer_Scalar is a subroutine used to output an intrinsic integer equal to an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a1b4787b08e3af49020e71cc1e07e79c2">More...</a><br /></td></tr>
<tr class="separator:a1b4787b08e3af49020e71cc1e07e79c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a5d645191f50e053bf5c79f2d8b14c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae7a5d645191f50e053bf5c79f2d8b14c">mqc_output_real_scalar</a> (ScalarOut, ScalarIn)</td></tr>
<tr class="memdesc:ae7a5d645191f50e053bf5c79f2d8b14c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Output_Real_Scalar is a subroutine used to output an intrinsic real equal to an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ae7a5d645191f50e053bf5c79f2d8b14c">More...</a><br /></td></tr>
<tr class="separator:ae7a5d645191f50e053bf5c79f2d8b14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96121d1d330a9dff5a51182cd598f6fd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a96121d1d330a9dff5a51182cd598f6fd">mqc_output_complex_scalar</a> (ScalarOut, ScalarIn)</td></tr>
<tr class="memdesc:a96121d1d330a9dff5a51182cd598f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Output_Complex_Scalar is a subroutine used to output an intrinsic complex equal to an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a96121d1d330a9dff5a51182cd598f6fd">More...</a><br /></td></tr>
<tr class="separator:a96121d1d330a9dff5a51182cd598f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5670e978555bc722597a13578193113d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5670e978555bc722597a13578193113d">mqc_print_scalar_algebra1</a> (Scalar, IOut, Header, Blank_At_Top, Blank_At_Bottom)</td></tr>
<tr class="memdesc:a5670e978555bc722597a13578193113d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Print_Scalar_Algebra1 is a subroutine used to print an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a5670e978555bc722597a13578193113d">More...</a><br /></td></tr>
<tr class="separator:a5670e978555bc722597a13578193113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f4c6cbf89a7d3091e7a05a70def10"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5c3f4c6cbf89a7d3091e7a05a70def10">mqc_scalar_cmplx</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a5c3f4c6cbf89a7d3091e7a05a70def10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Cmplx is a function used to set a complex MQC_Scalar type variable from two other MQC_scalars</b>  <a href="namespacemqc__algebra.html#a5c3f4c6cbf89a7d3091e7a05a70def10">More...</a><br /></td></tr>
<tr class="separator:a5c3f4c6cbf89a7d3091e7a05a70def10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48183353286c23747df863dd562aa8b8"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a48183353286c23747df863dd562aa8b8">mqc_scalar_sqrt</a> (Scalar)</td></tr>
<tr class="memdesc:a48183353286c23747df863dd562aa8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Sqrt is a function used to return the square root of an MQC_scalar</b>  <a href="namespacemqc__algebra.html#a48183353286c23747df863dd562aa8b8">More...</a><br /></td></tr>
<tr class="separator:a48183353286c23747df863dd562aa8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d52c71bb3f25dd7c05d7dea7cf922b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a49d52c71bb3f25dd7c05d7dea7cf922b">mqc_scalar_sin</a> (Scalar)</td></tr>
<tr class="memdesc:a49d52c71bb3f25dd7c05d7dea7cf922b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Sin is a function used to return the sine of an MQC_scalar</b>  <a href="namespacemqc__algebra.html#a49d52c71bb3f25dd7c05d7dea7cf922b">More...</a><br /></td></tr>
<tr class="separator:a49d52c71bb3f25dd7c05d7dea7cf922b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82434bee8bd4e7535e23968f39c004c"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac82434bee8bd4e7535e23968f39c004c">mqc_scalar_cos</a> (Scalar)</td></tr>
<tr class="memdesc:ac82434bee8bd4e7535e23968f39c004c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Cos is a function used to return the cosine of an MQC_scalar</b>  <a href="namespacemqc__algebra.html#ac82434bee8bd4e7535e23968f39c004c">More...</a><br /></td></tr>
<tr class="separator:ac82434bee8bd4e7535e23968f39c004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860726fae10ec3b3f92451c5d4bfbc52"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a860726fae10ec3b3f92451c5d4bfbc52">mqc_scalar_tan</a> (Scalar)</td></tr>
<tr class="memdesc:a860726fae10ec3b3f92451c5d4bfbc52"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Tan is a function used to return the tangent of an MQC_scalar</b>  <a href="namespacemqc__algebra.html#a860726fae10ec3b3f92451c5d4bfbc52">More...</a><br /></td></tr>
<tr class="separator:a860726fae10ec3b3f92451c5d4bfbc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1798346798e9e802b6387fe247f20b71"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a1798346798e9e802b6387fe247f20b71">mqc_scalar_asin</a> (Scalar)</td></tr>
<tr class="memdesc:a1798346798e9e802b6387fe247f20b71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_ASin is a function used to return the arcsin of an MQC_scalar</b>  <a href="namespacemqc__algebra.html#a1798346798e9e802b6387fe247f20b71">More...</a><br /></td></tr>
<tr class="separator:a1798346798e9e802b6387fe247f20b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95af3b088b74de094de82c7cb295fd52"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a95af3b088b74de094de82c7cb295fd52">mqc_scalar_acos</a> (Scalar)</td></tr>
<tr class="memdesc:a95af3b088b74de094de82c7cb295fd52"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_ACos is a function used to return the arccosine of an MQC_scalar</b>  <a href="namespacemqc__algebra.html#a95af3b088b74de094de82c7cb295fd52">More...</a><br /></td></tr>
<tr class="separator:a95af3b088b74de094de82c7cb295fd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aedd6ad2e5ae41c15bf5189872fa807"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6aedd6ad2e5ae41c15bf5189872fa807">mqc_scalar_atan</a> (Scalar)</td></tr>
<tr class="memdesc:a6aedd6ad2e5ae41c15bf5189872fa807"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_ATan is a function used to return the arctangent of an MQC_scalar</b>  <a href="namespacemqc__algebra.html#a6aedd6ad2e5ae41c15bf5189872fa807">More...</a><br /></td></tr>
<tr class="separator:a6aedd6ad2e5ae41c15bf5189872fa807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef50435730a6d10b5d32b4a991a8321"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5ef50435730a6d10b5d32b4a991a8321">mqc_scalar_atan2</a> (Scalar)</td></tr>
<tr class="memdesc:a5ef50435730a6d10b5d32b4a991a8321"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_ATan2 is a function used to return the arctangent of an MQC_scalar accounting for quadrant of Argand diagram</b>  <a href="namespacemqc__algebra.html#a5ef50435730a6d10b5d32b4a991a8321">More...</a><br /></td></tr>
<tr class="separator:a5ef50435730a6d10b5d32b4a991a8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f6c8700d153955e163ca7872c51dc7"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a44f6c8700d153955e163ca7872c51dc7">mqc_scalar_havereal</a> (Scalar)</td></tr>
<tr class="memdesc:a44f6c8700d153955e163ca7872c51dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_HaveReal is a function that returns TRUE or FALSE indicating whether an MQC_scalar is of type real</b>  <a href="namespacemqc__algebra.html#a44f6c8700d153955e163ca7872c51dc7">More...</a><br /></td></tr>
<tr class="separator:a44f6c8700d153955e163ca7872c51dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4174a790e525f23d3f4bd73e8f29fa1"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ad4174a790e525f23d3f4bd73e8f29fa1">mqc_scalar_haveinteger</a> (Scalar)</td></tr>
<tr class="memdesc:ad4174a790e525f23d3f4bd73e8f29fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_HaveInteger is a function that returns TRUE or FALSE indicating whether an MQC_scalar is of type integer</b>  <a href="namespacemqc__algebra.html#ad4174a790e525f23d3f4bd73e8f29fa1">More...</a><br /></td></tr>
<tr class="separator:ad4174a790e525f23d3f4bd73e8f29fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57212825ab5c80d980d69fc9f9d86611"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a57212825ab5c80d980d69fc9f9d86611">mqc_scalar_havecomplex</a> (Scalar)</td></tr>
<tr class="memdesc:a57212825ab5c80d980d69fc9f9d86611"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_HaveComplex is a function that returns TRUE or FALSE indicating whether an MQC_scalar is of type complex</b>  <a href="namespacemqc__algebra.html#a57212825ab5c80d980d69fc9f9d86611">More...</a><br /></td></tr>
<tr class="separator:a57212825ab5c80d980d69fc9f9d86611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b46fb61fbda788dfa6f3631c67fcac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5b46fb61fbda788dfa6f3631c67fcac1">mqc_scalar_get_intrinsic_real</a> (Scalar)</td></tr>
<tr class="memdesc:a5b46fb61fbda788dfa6f3631c67fcac1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Get_Intrinsic_Real is a function that returns the MQC_scalar value as an intrinsic real</b>  <a href="namespacemqc__algebra.html#a5b46fb61fbda788dfa6f3631c67fcac1">More...</a><br /></td></tr>
<tr class="separator:a5b46fb61fbda788dfa6f3631c67fcac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71295f7ab29e9d87330ecd7fcc133d4"><td class="memItemLeft" align="right" valign="top">integer(kind=int64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af71295f7ab29e9d87330ecd7fcc133d4">mqc_scalar_get_intrinsic_integer</a> (Scalar)</td></tr>
<tr class="memdesc:af71295f7ab29e9d87330ecd7fcc133d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Get_Intrinsic_Integer is a function that returns the MQC_scalar value as an intrinsic integer</b>  <a href="namespacemqc__algebra.html#af71295f7ab29e9d87330ecd7fcc133d4">More...</a><br /></td></tr>
<tr class="separator:af71295f7ab29e9d87330ecd7fcc133d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f017191f779ad512979693572104f7"><td class="memItemLeft" align="right" valign="top">complex(kind=real64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af2f017191f779ad512979693572104f7">mqc_scalar_get_intrinsic_complex</a> (Scalar)</td></tr>
<tr class="memdesc:af2f017191f779ad512979693572104f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Get_Intrinsic_Complex is a function that returns the MQC_scalar value as an intrinsic complex</b>  <a href="namespacemqc__algebra.html#af2f017191f779ad512979693572104f7">More...</a><br /></td></tr>
<tr class="separator:af2f017191f779ad512979693572104f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dde75fe02e3744f5f6da074ac4c0f39"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a3dde75fe02e3744f5f6da074ac4c0f39">mqc_scalar_get_abs_value</a> (Scalar)</td></tr>
<tr class="memdesc:a3dde75fe02e3744f5f6da074ac4c0f39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Get_ABS_Value is a function that returns the absolute value of MQC_scalar variable</b>  <a href="namespacemqc__algebra.html#a3dde75fe02e3744f5f6da074ac4c0f39">More...</a><br /></td></tr>
<tr class="separator:a3dde75fe02e3744f5f6da074ac4c0f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a974cc8a6293e353f55b61b8e3f80e0"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7a974cc8a6293e353f55b61b8e3f80e0">mqc_scalar_get_random_value</a> (Scalar, Seed, Distribution)</td></tr>
<tr class="memdesc:a7a974cc8a6293e353f55b61b8e3f80e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Get_Random_Value is a function that returns a random real value from a specified distribution</b>  <a href="namespacemqc__algebra.html#a7a974cc8a6293e353f55b61b8e3f80e0">More...</a><br /></td></tr>
<tr class="separator:a7a974cc8a6293e353f55b61b8e3f80e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e549ede414a6f0b7d4533b532602eac"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7e549ede414a6f0b7d4533b532602eac">mqc_scalaradd</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a7e549ede414a6f0b7d4533b532602eac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarAdd is a function that sums two MQC_Scalar objects</b>  <a href="namespacemqc__algebra.html#a7e549ede414a6f0b7d4533b532602eac">More...</a><br /></td></tr>
<tr class="separator:a7e549ede414a6f0b7d4533b532602eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab142473388c5cc3a397b64224eb3befa"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab142473388c5cc3a397b64224eb3befa">mqc_scalarsubtract</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:ab142473388c5cc3a397b64224eb3befa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarSubtract is a function that subtracts two MQC_Scalar objects</b>  <a href="namespacemqc__algebra.html#ab142473388c5cc3a397b64224eb3befa">More...</a><br /></td></tr>
<tr class="separator:ab142473388c5cc3a397b64224eb3befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bb7eafe1ebcfc572969d1677eefbff"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab3bb7eafe1ebcfc572969d1677eefbff">mqc_scalarmultiply</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:ab3bb7eafe1ebcfc572969d1677eefbff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarMultiply is a function that multiplies two MQC_Scalar objects</b>  <a href="namespacemqc__algebra.html#ab3bb7eafe1ebcfc572969d1677eefbff">More...</a><br /></td></tr>
<tr class="separator:ab3bb7eafe1ebcfc572969d1677eefbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3544d5de10c82ed17fc39b359be9089"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac3544d5de10c82ed17fc39b359be9089">mqc_scalardivide</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:ac3544d5de10c82ed17fc39b359be9089"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarDivide is a function that divides two MQC_Scalar objects</b>  <a href="namespacemqc__algebra.html#ac3544d5de10c82ed17fc39b359be9089">More...</a><br /></td></tr>
<tr class="separator:ac3544d5de10c82ed17fc39b359be9089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74199060019d514fa5064c354a479c96"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a74199060019d514fa5064c354a479c96">mqc_scalarexponent</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a74199060019d514fa5064c354a479c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarExponent is a function that raises one MQC_Scalar to the power of another MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a74199060019d514fa5064c354a479c96">More...</a><br /></td></tr>
<tr class="separator:a74199060019d514fa5064c354a479c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af993c7e2cc78b87876c1c3cc9f8d9b2e"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af993c7e2cc78b87876c1c3cc9f8d9b2e">mqc_scalarintegerexponent</a> (Scalar, IntIn)</td></tr>
<tr class="memdesc:af993c7e2cc78b87876c1c3cc9f8d9b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarIntegerExponent is a function that raises an MQC_Scalar to the power of an intrinsic integer</b>  <a href="namespacemqc__algebra.html#af993c7e2cc78b87876c1c3cc9f8d9b2e">More...</a><br /></td></tr>
<tr class="separator:af993c7e2cc78b87876c1c3cc9f8d9b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd6b4aad86126fe0ae97e65f1e19a00"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#affd6b4aad86126fe0ae97e65f1e19a00">mqc_scalarrealexponent</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:affd6b4aad86126fe0ae97e65f1e19a00"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarRealExponent is a function that raises an MQC_Scalar to the power of an intrinsic real</b>  <a href="namespacemqc__algebra.html#affd6b4aad86126fe0ae97e65f1e19a00">More...</a><br /></td></tr>
<tr class="separator:affd6b4aad86126fe0ae97e65f1e19a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441274a6033cb145846b8ad2025e87c6"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a441274a6033cb145846b8ad2025e87c6">mqc_scalarcomplexexponent</a> (Scalar, CompIn)</td></tr>
<tr class="memdesc:a441274a6033cb145846b8ad2025e87c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarComplexExponent is a function that raises an MQC_Scalar to the power of an intrinsic complex</b>  <a href="namespacemqc__algebra.html#a441274a6033cb145846b8ad2025e87c6">More...</a><br /></td></tr>
<tr class="separator:a441274a6033cb145846b8ad2025e87c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9d3434fe330c47bfa7428974e77ec5"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#afa9d3434fe330c47bfa7428974e77ec5">mqc_scalarne</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:afa9d3434fe330c47bfa7428974e77ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarNE is a function that returns TRUE if two MQC_Scalar variables are not equal</b>  <a href="namespacemqc__algebra.html#afa9d3434fe330c47bfa7428974e77ec5">More...</a><br /></td></tr>
<tr class="separator:afa9d3434fe330c47bfa7428974e77ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b654f9c495b768a42c40196b8a9188b"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a9b654f9c495b768a42c40196b8a9188b">mqc_scalareq</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a9b654f9c495b768a42c40196b8a9188b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarEQ is a function that returns TRUE if two MQC_Scalar variables are equal</b>  <a href="namespacemqc__algebra.html#a9b654f9c495b768a42c40196b8a9188b">More...</a><br /></td></tr>
<tr class="separator:a9b654f9c495b768a42c40196b8a9188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671f760b8ee1ec7373259ae83057116f"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a671f760b8ee1ec7373259ae83057116f">mqc_scalarlt</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a671f760b8ee1ec7373259ae83057116f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarLT is a function that returns TRUE if the left MQC_Scalar is less than the right MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a671f760b8ee1ec7373259ae83057116f">More...</a><br /></td></tr>
<tr class="separator:a671f760b8ee1ec7373259ae83057116f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92daddcf574bca2e97a35d004ecbf90"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab92daddcf574bca2e97a35d004ecbf90">mqc_realltscalar</a> (RealIn, Scalar)</td></tr>
<tr class="memdesc:ab92daddcf574bca2e97a35d004ecbf90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealLTScalar is a function that returns TRUE if an intrinsic real is less than a MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ab92daddcf574bca2e97a35d004ecbf90">More...</a><br /></td></tr>
<tr class="separator:ab92daddcf574bca2e97a35d004ecbf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956c2239f00621becee82131328d1eaf"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a956c2239f00621becee82131328d1eaf">mqc_scalarltreal</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:a956c2239f00621becee82131328d1eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarLTReal is a function that returns TRUE if a MQC_Scalar is less than an intrinsic real</b>  <a href="namespacemqc__algebra.html#a956c2239f00621becee82131328d1eaf">More...</a><br /></td></tr>
<tr class="separator:a956c2239f00621becee82131328d1eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4533fe7f7037b8a3d087346a008593e2"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a4533fe7f7037b8a3d087346a008593e2">mqc_scalargt</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a4533fe7f7037b8a3d087346a008593e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarGT is a function that returns TRUE if the left MQC_Scalar is greater than the right MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a4533fe7f7037b8a3d087346a008593e2">More...</a><br /></td></tr>
<tr class="separator:a4533fe7f7037b8a3d087346a008593e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88b633e98529241ac0027699711cff4"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae88b633e98529241ac0027699711cff4">mqc_integergtscalar</a> (IntIn, Scalar)</td></tr>
<tr class="memdesc:ae88b633e98529241ac0027699711cff4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_IntegerGTScalar is a function that returns TRUE if an intrinsic integer is greater than a MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ae88b633e98529241ac0027699711cff4">More...</a><br /></td></tr>
<tr class="separator:ae88b633e98529241ac0027699711cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f15df9068743c0e9ec802a07f9c736"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ad9f15df9068743c0e9ec802a07f9c736">mqc_scalargtinteger</a> (Scalar, IntIn)</td></tr>
<tr class="memdesc:ad9f15df9068743c0e9ec802a07f9c736"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarGTInteger is a function that returns TRUE if a MQC_Scalar is greater than an intrinsic integer</b>  <a href="namespacemqc__algebra.html#ad9f15df9068743c0e9ec802a07f9c736">More...</a><br /></td></tr>
<tr class="separator:ad9f15df9068743c0e9ec802a07f9c736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a411d628bc48e836f1e9446f6400a88"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5a411d628bc48e836f1e9446f6400a88">mqc_realgtscalar</a> (RealIn, Scalar)</td></tr>
<tr class="memdesc:a5a411d628bc48e836f1e9446f6400a88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealGTScalar is a function that returns TRUE if an intrinsic real is greater than a MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a5a411d628bc48e836f1e9446f6400a88">More...</a><br /></td></tr>
<tr class="separator:a5a411d628bc48e836f1e9446f6400a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b3e0f81e6b62300e79a85b9a2820af"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a74b3e0f81e6b62300e79a85b9a2820af">mqc_scalargtreal</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:a74b3e0f81e6b62300e79a85b9a2820af"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarGTReal is a function that returns TRUE if a MQC_Scalar is greater than an intrinsic real</b>  <a href="namespacemqc__algebra.html#a74b3e0f81e6b62300e79a85b9a2820af">More...</a><br /></td></tr>
<tr class="separator:a74b3e0f81e6b62300e79a85b9a2820af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b9aaef343779f7ec75161b6e62edfe"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a72b9aaef343779f7ec75161b6e62edfe">mqc_scalarle</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a72b9aaef343779f7ec75161b6e62edfe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarLE is a function that returns TRUE if the left MQC_Scalar is less than or equal the right MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a72b9aaef343779f7ec75161b6e62edfe">More...</a><br /></td></tr>
<tr class="separator:a72b9aaef343779f7ec75161b6e62edfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3c883ffc8067c04af4c5c9a2351cbc"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#afb3c883ffc8067c04af4c5c9a2351cbc">mqc_reallescalar</a> (RealIn, Scalar)</td></tr>
<tr class="memdesc:afb3c883ffc8067c04af4c5c9a2351cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealLEScalar is a function that returns TRUE if an intrinsic real is less than or equal to a MQC_Scalar</b>  <a href="namespacemqc__algebra.html#afb3c883ffc8067c04af4c5c9a2351cbc">More...</a><br /></td></tr>
<tr class="separator:afb3c883ffc8067c04af4c5c9a2351cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1998cf7bec418ce41907712998634d88"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a1998cf7bec418ce41907712998634d88">mqc_scalarlereal</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:a1998cf7bec418ce41907712998634d88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarLEReal is a function that returns TRUE if a MQC_Scalar is less than or equal to an intrinsic real</b>  <a href="namespacemqc__algebra.html#a1998cf7bec418ce41907712998634d88">More...</a><br /></td></tr>
<tr class="separator:a1998cf7bec418ce41907712998634d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd72b97a1b34f869365e71dcc031af5"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#abdd72b97a1b34f869365e71dcc031af5">mqc_integerlescalar</a> (IntIn, Scalar)</td></tr>
<tr class="memdesc:abdd72b97a1b34f869365e71dcc031af5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_IntegerLEScalar is a function that returns TRUE if an intrinsic integer is less than or equal to a MQC_Scalar</b>  <a href="namespacemqc__algebra.html#abdd72b97a1b34f869365e71dcc031af5">More...</a><br /></td></tr>
<tr class="separator:abdd72b97a1b34f869365e71dcc031af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c752a369012f86a452b8fc6c3c1ad0"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a86c752a369012f86a452b8fc6c3c1ad0">mqc_scalarleinteger</a> (Scalar, IntIn)</td></tr>
<tr class="memdesc:a86c752a369012f86a452b8fc6c3c1ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarLEInteger is a function that returns TRUE if a MQC_Scalar is less than or equal to an intrinsic integer</b>  <a href="namespacemqc__algebra.html#a86c752a369012f86a452b8fc6c3c1ad0">More...</a><br /></td></tr>
<tr class="separator:a86c752a369012f86a452b8fc6c3c1ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b5159e0089cd791c245e99cbf3a1e3"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a07b5159e0089cd791c245e99cbf3a1e3">mqc_scalarge</a> (Scalar1, Scalar2)</td></tr>
<tr class="memdesc:a07b5159e0089cd791c245e99cbf3a1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarGE is a function that returns TRUE if the left MQC_Scalar is greater than or equal the right MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a07b5159e0089cd791c245e99cbf3a1e3">More...</a><br /></td></tr>
<tr class="separator:a07b5159e0089cd791c245e99cbf3a1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa021bafadf4e7694dfc4aa647b9e6743"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa021bafadf4e7694dfc4aa647b9e6743">mqc_scalar_complex_conjugate</a> (ScalarIn)</td></tr>
<tr class="memdesc:aa021bafadf4e7694dfc4aa647b9e6743"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Complex_Conjugate is a function that returns the complex conjugate of an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#aa021bafadf4e7694dfc4aa647b9e6743">More...</a><br /></td></tr>
<tr class="separator:aa021bafadf4e7694dfc4aa647b9e6743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064e55d8a10812f4423d4c7c85db064c"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a064e55d8a10812f4423d4c7c85db064c">mqc_scalar_complex_realpart</a> (ScalarIn)</td></tr>
<tr class="memdesc:a064e55d8a10812f4423d4c7c85db064c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Complex_RealPart is a function that returns the real part of an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a064e55d8a10812f4423d4c7c85db064c">More...</a><br /></td></tr>
<tr class="separator:a064e55d8a10812f4423d4c7c85db064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486846cf71687686d5d1cd5a91f4959b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a486846cf71687686d5d1cd5a91f4959b">mqc_scalar_complex_imagpart</a> (ScalarIn)</td></tr>
<tr class="memdesc:a486846cf71687686d5d1cd5a91f4959b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Scalar_Complex_ImagPart is a function that returns the inaginary part of an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a486846cf71687686d5d1cd5a91f4959b">More...</a><br /></td></tr>
<tr class="separator:a486846cf71687686d5d1cd5a91f4959b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0611c528322a72b23eedfb2fcfa0b5cd"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a0611c528322a72b23eedfb2fcfa0b5cd">mqc_integerscalarmultiply</a> (IntegerIn, Scalar)</td></tr>
<tr class="memdesc:a0611c528322a72b23eedfb2fcfa0b5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_IntegerScalarMultiply is a function that is used to multiply an intrinsic integer by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a0611c528322a72b23eedfb2fcfa0b5cd">More...</a><br /></td></tr>
<tr class="separator:a0611c528322a72b23eedfb2fcfa0b5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4acb398a6dad0fda3d3ddbfd78898b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a3e4acb398a6dad0fda3d3ddbfd78898b">mqc_scalarintegermultiply</a> (Scalar, IntegerIn)</td></tr>
<tr class="memdesc:a3e4acb398a6dad0fda3d3ddbfd78898b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarIntegerMultiply is a function that is used to multiply an intrinsic integer by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a3e4acb398a6dad0fda3d3ddbfd78898b">More...</a><br /></td></tr>
<tr class="separator:a3e4acb398a6dad0fda3d3ddbfd78898b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c0fa9503e54a88841d9f5b3afc7a21"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a06c0fa9503e54a88841d9f5b3afc7a21">mqc_realscalarmultiply</a> (RealIn, Scalar)</td></tr>
<tr class="memdesc:a06c0fa9503e54a88841d9f5b3afc7a21"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealScalarMultiply is a function that is used to multiply an intrinsic real by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a06c0fa9503e54a88841d9f5b3afc7a21">More...</a><br /></td></tr>
<tr class="separator:a06c0fa9503e54a88841d9f5b3afc7a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cbafa5e66d0700c76e4157189c9095"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a23cbafa5e66d0700c76e4157189c9095">mqc_scalarrealmultiply</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:a23cbafa5e66d0700c76e4157189c9095"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarRealMultiply is a function that is used to multiply an intrinsic real by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a23cbafa5e66d0700c76e4157189c9095">More...</a><br /></td></tr>
<tr class="separator:a23cbafa5e66d0700c76e4157189c9095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff0ad4fff7388aa7ec919e750b39c1"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#accff0ad4fff7388aa7ec919e750b39c1">mqc_complexscalarmultiply</a> (ComplexIn, Scalar)</td></tr>
<tr class="memdesc:accff0ad4fff7388aa7ec919e750b39c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ComplexScalarMultiply is a function that is used to multiply an intrinsic complex by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#accff0ad4fff7388aa7ec919e750b39c1">More...</a><br /></td></tr>
<tr class="separator:accff0ad4fff7388aa7ec919e750b39c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf29d4cc0a3ec01a7c66bc796ae1562"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a4cf29d4cc0a3ec01a7c66bc796ae1562">mqc_scalarcomplexmultiply</a> (Scalar, ComplexIn)</td></tr>
<tr class="memdesc:a4cf29d4cc0a3ec01a7c66bc796ae1562"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarComplexMultiply is a function that is used to multiply an intrinsic complex by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a4cf29d4cc0a3ec01a7c66bc796ae1562">More...</a><br /></td></tr>
<tr class="separator:a4cf29d4cc0a3ec01a7c66bc796ae1562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51aeec216cc444858a35ab2a50f4c069"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a51aeec216cc444858a35ab2a50f4c069">mqc_integerscalardivide</a> (IntegerIn, Scalar)</td></tr>
<tr class="memdesc:a51aeec216cc444858a35ab2a50f4c069"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_IntegerScalarDivide is a function that is used to divide an intrinsic integer by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a51aeec216cc444858a35ab2a50f4c069">More...</a><br /></td></tr>
<tr class="separator:a51aeec216cc444858a35ab2a50f4c069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e83bd05393481b1d246858e38f7bf4"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae1e83bd05393481b1d246858e38f7bf4">mqc_scalarintegerdivide</a> (Scalar, IntegerIn)</td></tr>
<tr class="memdesc:ae1e83bd05393481b1d246858e38f7bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarIntegerDivide is a function that is used to divide an MQC_Scalar by an intrinsic integer</b>  <a href="namespacemqc__algebra.html#ae1e83bd05393481b1d246858e38f7bf4">More...</a><br /></td></tr>
<tr class="separator:ae1e83bd05393481b1d246858e38f7bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52a7f2f065dde607c59f11a33fa6b68"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa52a7f2f065dde607c59f11a33fa6b68">mqc_realscalardivide</a> (RealIn, Scalar)</td></tr>
<tr class="memdesc:aa52a7f2f065dde607c59f11a33fa6b68"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealScalarDivide is a function that is used to divide an intrinsic real by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#aa52a7f2f065dde607c59f11a33fa6b68">More...</a><br /></td></tr>
<tr class="separator:aa52a7f2f065dde607c59f11a33fa6b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341525976717733d32c5ba56b9a585b8"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a341525976717733d32c5ba56b9a585b8">mqc_scalarrealdivide</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:a341525976717733d32c5ba56b9a585b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarRealDivide is a function that is used to divide an MQC_Scalar by an intrinsic real</b>  <a href="namespacemqc__algebra.html#a341525976717733d32c5ba56b9a585b8">More...</a><br /></td></tr>
<tr class="separator:a341525976717733d32c5ba56b9a585b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43b6ab656657a60c626d3ce59599414"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac43b6ab656657a60c626d3ce59599414">mqc_complexscalardivide</a> (ComplexIn, Scalar)</td></tr>
<tr class="memdesc:ac43b6ab656657a60c626d3ce59599414"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ComplexScalarDivide is a function that is used to divide an intrinsic complex by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ac43b6ab656657a60c626d3ce59599414">More...</a><br /></td></tr>
<tr class="separator:ac43b6ab656657a60c626d3ce59599414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d179bcbbe61d625060fc313863b9842"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a3d179bcbbe61d625060fc313863b9842">mqc_scalarcomplexdivide</a> (Scalar, ComplexIn)</td></tr>
<tr class="memdesc:a3d179bcbbe61d625060fc313863b9842"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarComplexDivide is a function that is used to divide an MQC_Scalar by an intrinsic complex</b>  <a href="namespacemqc__algebra.html#a3d179bcbbe61d625060fc313863b9842">More...</a><br /></td></tr>
<tr class="separator:a3d179bcbbe61d625060fc313863b9842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce708060612d891456764837300437"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a07ce708060612d891456764837300437">mqc_integerscalaradd</a> (IntegerIn, Scalar)</td></tr>
<tr class="memdesc:a07ce708060612d891456764837300437"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_IntegerScalarAdd is a function that is used to multiply an intrinsic integer by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a07ce708060612d891456764837300437">More...</a><br /></td></tr>
<tr class="separator:a07ce708060612d891456764837300437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2963d6cff1c4da599359df46e094770a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a2963d6cff1c4da599359df46e094770a">mqc_scalarintegeradd</a> (Scalar, IntegerIn)</td></tr>
<tr class="memdesc:a2963d6cff1c4da599359df46e094770a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarIntegerAdd is a function that is used to sum an intrinsic integer by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a2963d6cff1c4da599359df46e094770a">More...</a><br /></td></tr>
<tr class="separator:a2963d6cff1c4da599359df46e094770a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48627500935e05d982407ab0adbe144"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ad48627500935e05d982407ab0adbe144">mqc_realscalaradd</a> (RealIn, Scalar)</td></tr>
<tr class="memdesc:ad48627500935e05d982407ab0adbe144"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealScalarAdd is a function that is used to sum an intrinsic real by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ad48627500935e05d982407ab0adbe144">More...</a><br /></td></tr>
<tr class="separator:ad48627500935e05d982407ab0adbe144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45c4db95c648b8ce5d240d7b1198be4"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa45c4db95c648b8ce5d240d7b1198be4">mqc_scalarrealadd</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:aa45c4db95c648b8ce5d240d7b1198be4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarRealAdd is a function that is used to sum an intrinsic real by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#aa45c4db95c648b8ce5d240d7b1198be4">More...</a><br /></td></tr>
<tr class="separator:aa45c4db95c648b8ce5d240d7b1198be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808c0cb549729a735e76fb23a224b6fe"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a808c0cb549729a735e76fb23a224b6fe">mqc_complexscalaradd</a> (ComplexIn, Scalar)</td></tr>
<tr class="memdesc:a808c0cb549729a735e76fb23a224b6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ComplexScalarAdd is a function that is used to sum an intrinsic complex by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a808c0cb549729a735e76fb23a224b6fe">More...</a><br /></td></tr>
<tr class="separator:a808c0cb549729a735e76fb23a224b6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9324f81f0ddb53ed3657042a1ca9a16"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab9324f81f0ddb53ed3657042a1ca9a16">mqc_scalarcomplexadd</a> (Scalar, ComplexIn)</td></tr>
<tr class="memdesc:ab9324f81f0ddb53ed3657042a1ca9a16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarComplexAdd is a function that is used to sum an intrinsic complex by an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ab9324f81f0ddb53ed3657042a1ca9a16">More...</a><br /></td></tr>
<tr class="separator:ab9324f81f0ddb53ed3657042a1ca9a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8441269618f9fb27d9c6b96f44401e23"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8441269618f9fb27d9c6b96f44401e23">mqc_integerscalarsubtract</a> (IntegerIn, Scalar)</td></tr>
<tr class="memdesc:a8441269618f9fb27d9c6b96f44401e23"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_IntegerScalarSubtract is a function that is used to subtract an MQC_Scalar from an intrinisic integer</b>  <a href="namespacemqc__algebra.html#a8441269618f9fb27d9c6b96f44401e23">More...</a><br /></td></tr>
<tr class="separator:a8441269618f9fb27d9c6b96f44401e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c67de0d6d4853006e5855382de532c"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac8c67de0d6d4853006e5855382de532c">mqc_scalarintegersubtract</a> (Scalar, IntegerIn)</td></tr>
<tr class="memdesc:ac8c67de0d6d4853006e5855382de532c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarIntegerSubtract is a function that is used to subtract an intrinsic integer from an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#ac8c67de0d6d4853006e5855382de532c">More...</a><br /></td></tr>
<tr class="separator:ac8c67de0d6d4853006e5855382de532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea3e486f62a29ff78bc55bc78898d4b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8ea3e486f62a29ff78bc55bc78898d4b">mqc_realscalarsubtract</a> (RealIn, Scalar)</td></tr>
<tr class="memdesc:a8ea3e486f62a29ff78bc55bc78898d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealScalarSubtract is a function that is used to subtract an MQC_Scalar from an intrinisic real</b>  <a href="namespacemqc__algebra.html#a8ea3e486f62a29ff78bc55bc78898d4b">More...</a><br /></td></tr>
<tr class="separator:a8ea3e486f62a29ff78bc55bc78898d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4d3df27b95d21dab20b1c7024aba61"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5e4d3df27b95d21dab20b1c7024aba61">mqc_scalarrealsubtract</a> (Scalar, RealIn)</td></tr>
<tr class="memdesc:a5e4d3df27b95d21dab20b1c7024aba61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarRealSubtract is a function that is used to subtract an intrinsic real from an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a5e4d3df27b95d21dab20b1c7024aba61">More...</a><br /></td></tr>
<tr class="separator:a5e4d3df27b95d21dab20b1c7024aba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb7c31e42137f86753c430312dfbc5"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab1eb7c31e42137f86753c430312dfbc5">mqc_complexscalarsubtract</a> (ComplexIn, Scalar)</td></tr>
<tr class="memdesc:ab1eb7c31e42137f86753c430312dfbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ComplexScalarSubtract is a function that is used to subtract an MQC_Scalar from an intrinisic complex</b>  <a href="namespacemqc__algebra.html#ab1eb7c31e42137f86753c430312dfbc5">More...</a><br /></td></tr>
<tr class="separator:ab1eb7c31e42137f86753c430312dfbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f607dd0cb298789506092e4d1a9593"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a90f607dd0cb298789506092e4d1a9593">mqc_scalarcomplexsubtract</a> (Scalar, ComplexIn)</td></tr>
<tr class="memdesc:a90f607dd0cb298789506092e4d1a9593"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarComplexSubtract is a function that is used to subtract an intrinsic complex from an MQC_Scalar</b>  <a href="namespacemqc__algebra.html#a90f607dd0cb298789506092e4d1a9593">More...</a><br /></td></tr>
<tr class="separator:a90f607dd0cb298789506092e4d1a9593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d6ff5efede7d1a15a1d31b11500bd2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a43d6ff5efede7d1a15a1d31b11500bd2">mqc_allocate_vector</a> (N, Vector, Data_Type)</td></tr>
<tr class="memdesc:a43d6ff5efede7d1a15a1d31b11500bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Allocate_Vector is used to allocate a vector type variable of the MQC_Vector class</b>  <a href="namespacemqc__algebra.html#a43d6ff5efede7d1a15a1d31b11500bd2">More...</a><br /></td></tr>
<tr class="separator:a43d6ff5efede7d1a15a1d31b11500bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeb2fe8ce3cd32371c13b18f8609df2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aabeb2fe8ce3cd32371c13b18f8609df2">mqc_deallocate_vector</a> (Vector)</td></tr>
<tr class="memdesc:aabeb2fe8ce3cd32371c13b18f8609df2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Deallocate_Vector is used to deallocate a vector type variable of the MQC_Vector class</b>  <a href="namespacemqc__algebra.html#aabeb2fe8ce3cd32371c13b18f8609df2">More...</a><br /></td></tr>
<tr class="separator:aabeb2fe8ce3cd32371c13b18f8609df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8914aee32665a30481184250b3cb0d96"><td class="memItemLeft" align="right" valign="top">integer(kind=int64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8914aee32665a30481184250b3cb0d96">mqc_length_vector</a> (Vector)</td></tr>
<tr class="memdesc:a8914aee32665a30481184250b3cb0d96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Length_Vector is used to return the length of an MQC vector</b>  <a href="namespacemqc__algebra.html#a8914aee32665a30481184250b3cb0d96">More...</a><br /></td></tr>
<tr class="separator:a8914aee32665a30481184250b3cb0d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0fdcc4b2036d9450895868acce7737"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5f0fdcc4b2036d9450895868acce7737">mqc_vector_havereal</a> (Vector)</td></tr>
<tr class="memdesc:a5f0fdcc4b2036d9450895868acce7737"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_HaveReal is a function that returns TRUE or FALSE indicating whether the MQC vector has an allocated real vector</b>  <a href="namespacemqc__algebra.html#a5f0fdcc4b2036d9450895868acce7737">More...</a><br /></td></tr>
<tr class="separator:a5f0fdcc4b2036d9450895868acce7737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32be9b1de2925fa4a4468ddeaea79485"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a32be9b1de2925fa4a4468ddeaea79485">mqc_vector_haveinteger</a> (Vector)</td></tr>
<tr class="memdesc:a32be9b1de2925fa4a4468ddeaea79485"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_HaveInteger is a function that returns TRUE or FALSE indicating whether the MQC vector has an allocated integer vector</b>  <a href="namespacemqc__algebra.html#a32be9b1de2925fa4a4468ddeaea79485">More...</a><br /></td></tr>
<tr class="separator:a32be9b1de2925fa4a4468ddeaea79485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6874ea143732147d6c425c509c642038"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6874ea143732147d6c425c509c642038">mqc_vector_havecomplex</a> (Vector)</td></tr>
<tr class="memdesc:a6874ea143732147d6c425c509c642038"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_HaveComplex is a function that returns TRUE or FALSE indicating whether the MQC vector has an allocated complex vector</b>  <a href="namespacemqc__algebra.html#a6874ea143732147d6c425c509c642038">More...</a><br /></td></tr>
<tr class="separator:a6874ea143732147d6c425c509c642038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44658ecaa7703ab847e67e9d625afcf2"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a44658ecaa7703ab847e67e9d625afcf2">mqc_vector_iscolumn</a> (Vector)</td></tr>
<tr class="memdesc:a44658ecaa7703ab847e67e9d625afcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_IsColumn is a function that returns TRUE if the MQC vector is a column vector and FALSE if the MQC vector is a row vector</b>  <a href="namespacemqc__algebra.html#a44658ecaa7703ab847e67e9d625afcf2">More...</a><br /></td></tr>
<tr class="separator:a44658ecaa7703ab847e67e9d625afcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbee00cc9b309180fa565476e23998c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a4fbee00cc9b309180fa565476e23998c">mqc_vector_copy_int2real</a> (Vector)</td></tr>
<tr class="memdesc:a4fbee00cc9b309180fa565476e23998c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Copy_Int2Real is a subroutine that copies an integer MQC_Vector into its real vector</b>  <a href="namespacemqc__algebra.html#a4fbee00cc9b309180fa565476e23998c">More...</a><br /></td></tr>
<tr class="separator:a4fbee00cc9b309180fa565476e23998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbe04990f7d7761d05d318fb6e87ecd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#addbe04990f7d7761d05d318fb6e87ecd">mqc_vector_copy_int2complex</a> (Vector)</td></tr>
<tr class="memdesc:addbe04990f7d7761d05d318fb6e87ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Copy_Int2Complex is a subroutine that copies an integer MQC_Vector into its complex vector</b>  <a href="namespacemqc__algebra.html#addbe04990f7d7761d05d318fb6e87ecd">More...</a><br /></td></tr>
<tr class="separator:addbe04990f7d7761d05d318fb6e87ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc2c3e1e2114b24ffc435bb61d77f45"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aefc2c3e1e2114b24ffc435bb61d77f45">mqc_vector_copy_real2int</a> (Vector)</td></tr>
<tr class="memdesc:aefc2c3e1e2114b24ffc435bb61d77f45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Copy_Real2Int is a subroutine that copies a real MQC_Vector into its integer vector</b>  <a href="namespacemqc__algebra.html#aefc2c3e1e2114b24ffc435bb61d77f45">More...</a><br /></td></tr>
<tr class="separator:aefc2c3e1e2114b24ffc435bb61d77f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad819f9da223284d2f47c9a9e1f3c6fa"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aad819f9da223284d2f47c9a9e1f3c6fa">mqc_vector_copy_real2complex</a> (Vector)</td></tr>
<tr class="memdesc:aad819f9da223284d2f47c9a9e1f3c6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Copy_Real2Complex is a subroutine that copies a real MQC_Vector into its complex vector</b>  <a href="namespacemqc__algebra.html#aad819f9da223284d2f47c9a9e1f3c6fa">More...</a><br /></td></tr>
<tr class="separator:aad819f9da223284d2f47c9a9e1f3c6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f4f9eb21c9089b2c6d60f72e700f9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a247f4f9eb21c9089b2c6d60f72e700f9">mqc_vector_copy_complex2int</a> (Vector)</td></tr>
<tr class="memdesc:a247f4f9eb21c9089b2c6d60f72e700f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Copy_Complex2Int is a subroutine that copies a complex MQC_Vector into its integer vector</b>  <a href="namespacemqc__algebra.html#a247f4f9eb21c9089b2c6d60f72e700f9">More...</a><br /></td></tr>
<tr class="separator:a247f4f9eb21c9089b2c6d60f72e700f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3a91a9b2e51be275947da30967b0e5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a0c3a91a9b2e51be275947da30967b0e5">mqc_vector_copy_complex2real</a> (Vector)</td></tr>
<tr class="memdesc:a0c3a91a9b2e51be275947da30967b0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Copy_Complex2Real is a subroutine that copies a complex MQC_Vector into its real vector</b>  <a href="namespacemqc__algebra.html#a0c3a91a9b2e51be275947da30967b0e5">More...</a><br /></td></tr>
<tr class="separator:a0c3a91a9b2e51be275947da30967b0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac096d0ab43b725951c3c8e88c54ae87b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac096d0ab43b725951c3c8e88c54ae87b">mqc_vector_scalar_at</a> (Vec, I)</td></tr>
<tr class="memdesc:ac096d0ab43b725951c3c8e88c54ae87b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Scalar_At is a function that returns the ith element of a MQC vector as an MQC scalar</b>  <a href="namespacemqc__algebra.html#ac096d0ab43b725951c3c8e88c54ae87b">More...</a><br /></td></tr>
<tr class="separator:ac096d0ab43b725951c3c8e88c54ae87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbfce3ed0b451faac3b15c6fbee1732"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#accbfce3ed0b451faac3b15c6fbee1732">mqc_vector_vector_at</a> (Vec, I, J)</td></tr>
<tr class="memdesc:accbfce3ed0b451faac3b15c6fbee1732"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Vector_At is a function that returns the vector at the specified subvector of MQC_Vector</b>  <a href="namespacemqc__algebra.html#accbfce3ed0b451faac3b15c6fbee1732">More...</a><br /></td></tr>
<tr class="separator:accbfce3ed0b451faac3b15c6fbee1732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba54eb450ce211317b02ef6f33ac2e4b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aba54eb450ce211317b02ef6f33ac2e4b">mqc_set_vector2integerarray</a> (ArrayOut, VectorIn)</td></tr>
<tr class="memdesc:aba54eb450ce211317b02ef6f33ac2e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Vector2IntegerArray is a subroutine that outputs an MQC vector to a rank 1 intrinsic integer array</b>  <a href="namespacemqc__algebra.html#aba54eb450ce211317b02ef6f33ac2e4b">More...</a><br /></td></tr>
<tr class="separator:aba54eb450ce211317b02ef6f33ac2e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c87333d1d226be9235bd76ed6dc8e14"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a2c87333d1d226be9235bd76ed6dc8e14">mqc_set_vector2realarray</a> (ArrayOut, VectorIn)</td></tr>
<tr class="memdesc:a2c87333d1d226be9235bd76ed6dc8e14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Vector2RealArray is a subroutine that outputs an MQC vector to a rank 1 intrinsic real array</b>  <a href="namespacemqc__algebra.html#a2c87333d1d226be9235bd76ed6dc8e14">More...</a><br /></td></tr>
<tr class="separator:a2c87333d1d226be9235bd76ed6dc8e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e6f949ac09346185c019c7217b92fb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a69e6f949ac09346185c019c7217b92fb">mqc_set_vector2complexarray</a> (ArrayOut, VectorIn)</td></tr>
<tr class="memdesc:a69e6f949ac09346185c019c7217b92fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Vector2ComplexArray is a subroutine that outputs an MQC vector to a rank 1 intrinsic complex array</b>  <a href="namespacemqc__algebra.html#a69e6f949ac09346185c019c7217b92fb">More...</a><br /></td></tr>
<tr class="separator:a69e6f949ac09346185c019c7217b92fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b93cf3b8fade6272fee7b028f55006"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab0b93cf3b8fade6272fee7b028f55006">mqc_set_array2vector_integer</a> (VectorOut, ArrayIn)</td></tr>
<tr class="memdesc:ab0b93cf3b8fade6272fee7b028f55006"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Array2Vector_Integer is a subroutine that sets a rank 1 intrinsic integer array equal to a MQC vector</b>  <a href="namespacemqc__algebra.html#ab0b93cf3b8fade6272fee7b028f55006">More...</a><br /></td></tr>
<tr class="separator:ab0b93cf3b8fade6272fee7b028f55006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cf2c2384fcf4256bdc24f147c99f70"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a26cf2c2384fcf4256bdc24f147c99f70">mqc_set_array2vector_real</a> (VectorOut, ArrayIn)</td></tr>
<tr class="memdesc:a26cf2c2384fcf4256bdc24f147c99f70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Array2Vector_Real is a subroutine that sets a rank 1 vector intrinsic real array equal to a MQC vector</b>  <a href="namespacemqc__algebra.html#a26cf2c2384fcf4256bdc24f147c99f70">More...</a><br /></td></tr>
<tr class="separator:a26cf2c2384fcf4256bdc24f147c99f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1a623e6244dccb485b3420d23ba38b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7d1a623e6244dccb485b3420d23ba38b">mqc_set_array2vector_complex</a> (VectorOut, ArrayIn)</td></tr>
<tr class="memdesc:a7d1a623e6244dccb485b3420d23ba38b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Array2Vector_Complex is a subroutine that sets a rank 1 vector intrinsic complex array equal to a MQC vector</b>  <a href="namespacemqc__algebra.html#a7d1a623e6244dccb485b3420d23ba38b">More...</a><br /></td></tr>
<tr class="separator:a7d1a623e6244dccb485b3420d23ba38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a7b85f2e0c573ff40f6af97eb6cfac"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a51a7b85f2e0c573ff40f6af97eb6cfac">mqc_set_vector2vector</a> (VectorOut, VectorIn)</td></tr>
<tr class="memdesc:a51a7b85f2e0c573ff40f6af97eb6cfac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Vector2Vector is a subroutine that sets a MQC vector equal to another MQC vector</b>  <a href="namespacemqc__algebra.html#a51a7b85f2e0c573ff40f6af97eb6cfac">More...</a><br /></td></tr>
<tr class="separator:a51a7b85f2e0c573ff40f6af97eb6cfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bfd1876b23289eadd3e0757c3475da"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af8bfd1876b23289eadd3e0757c3475da">mqc_vectorvectorsum</a> (Vector1In, Vector2In)</td></tr>
<tr class="memdesc:af8bfd1876b23289eadd3e0757c3475da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorVectorSum is a function that adds two MQC vectors and stores them in another MQC vector</b>  <a href="namespacemqc__algebra.html#af8bfd1876b23289eadd3e0757c3475da">More...</a><br /></td></tr>
<tr class="separator:af8bfd1876b23289eadd3e0757c3475da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b3db6ebf545d9371912f64cf99121"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af43b3db6ebf545d9371912f64cf99121">mqc_vectorvectordifference</a> (Vector1In, Vector2In)</td></tr>
<tr class="memdesc:af43b3db6ebf545d9371912f64cf99121"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorVectorDifference is a function that subtracts two MQC vectors and stores them in another MQC vector</b>  <a href="namespacemqc__algebra.html#af43b3db6ebf545d9371912f64cf99121">More...</a><br /></td></tr>
<tr class="separator:af43b3db6ebf545d9371912f64cf99121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fc4e9fe5034154c95a4b15725aa0ec"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a98fc4e9fe5034154c95a4b15725aa0ec">mqc_scalarvectorsum</a> (ScalarIn, VectorIn)</td></tr>
<tr class="memdesc:a98fc4e9fe5034154c95a4b15725aa0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarVectorSum is a function that adds an MQC scalar to all elements of an MQC vector</b>  <a href="namespacemqc__algebra.html#a98fc4e9fe5034154c95a4b15725aa0ec">More...</a><br /></td></tr>
<tr class="separator:a98fc4e9fe5034154c95a4b15725aa0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3b73dd48c7cab051876b9577877366"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#acc3b73dd48c7cab051876b9577877366">mqc_scalarvectordifference</a> (ScalarIn, VectorIn)</td></tr>
<tr class="memdesc:acc3b73dd48c7cab051876b9577877366"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarVectorDifference is a function that subtracts an MQC scalar from all elements of an MQC vector</b>  <a href="namespacemqc__algebra.html#acc3b73dd48c7cab051876b9577877366">More...</a><br /></td></tr>
<tr class="separator:acc3b73dd48c7cab051876b9577877366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577ba023f29432f58832d1cc6e29e182"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a577ba023f29432f58832d1cc6e29e182">mqc_elementvectorproduct</a> (Vector1In, Vector2In)</td></tr>
<tr class="memdesc:a577ba023f29432f58832d1cc6e29e182"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ElementVectorProduct is a function that multiplies two MQC vectors elementwise and stores them into another MQC vector</b>  <a href="namespacemqc__algebra.html#a577ba023f29432f58832d1cc6e29e182">More...</a><br /></td></tr>
<tr class="separator:a577ba023f29432f58832d1cc6e29e182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60686c80235aa8e05e96c69b25ee0196"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a60686c80235aa8e05e96c69b25ee0196">mqc_vector_transpose</a> (Vector)</td></tr>
<tr class="memdesc:a60686c80235aa8e05e96c69b25ee0196"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Transpose is a function that returns the transpose of an MQC vector</b>  <a href="namespacemqc__algebra.html#a60686c80235aa8e05e96c69b25ee0196">More...</a><br /></td></tr>
<tr class="separator:a60686c80235aa8e05e96c69b25ee0196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc43bf9008f4f5892e2a87eab2786d3"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5cc43bf9008f4f5892e2a87eab2786d3">mqc_vector_conjugate_transpose</a> (Vector)</td></tr>
<tr class="memdesc:a5cc43bf9008f4f5892e2a87eab2786d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Conjugate_Transpose is a function that returns the conjugate transpose of an MQC vector</b>  <a href="namespacemqc__algebra.html#a5cc43bf9008f4f5892e2a87eab2786d3">More...</a><br /></td></tr>
<tr class="separator:a5cc43bf9008f4f5892e2a87eab2786d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfde21d87680d8d12ea399f5e2f13b7a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#acfde21d87680d8d12ea399f5e2f13b7a">mqc_vectorvectordotproduct</a> (Vector1, Vector2)</td></tr>
<tr class="memdesc:acfde21d87680d8d12ea399f5e2f13b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorVectorDotProduct is a function that returns the dot product of two MQC vectors</b>  <a href="namespacemqc__algebra.html#acfde21d87680d8d12ea399f5e2f13b7a">More...</a><br /></td></tr>
<tr class="separator:acfde21d87680d8d12ea399f5e2f13b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62c5033c0d7cbc2cf794d2215f15873"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae62c5033c0d7cbc2cf794d2215f15873">mqc_outer</a> (VA, VB)</td></tr>
<tr class="memdesc:ae62c5033c0d7cbc2cf794d2215f15873"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Outer is a function that returns the outer product of two MQC vectors</b>  <a href="namespacemqc__algebra.html#ae62c5033c0d7cbc2cf794d2215f15873">More...</a><br /></td></tr>
<tr class="separator:ae62c5033c0d7cbc2cf794d2215f15873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d8e1c15eb8c2bef8793e3fbb0b9d11"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af1d8e1c15eb8c2bef8793e3fbb0b9d11">mqc_crossproduct</a> (Vector1In, Vector2In)</td></tr>
<tr class="memdesc:af1d8e1c15eb8c2bef8793e3fbb0b9d11"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_CrossProduct is a function that returns the cross product of two MQC vectors</b>  <a href="namespacemqc__algebra.html#af1d8e1c15eb8c2bef8793e3fbb0b9d11">More...</a><br /></td></tr>
<tr class="separator:af1d8e1c15eb8c2bef8793e3fbb0b9d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64f8cd347b0d00129d7fce3ea323c46"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae64f8cd347b0d00129d7fce3ea323c46">mqc_print_vector_algebra1</a> (Vector, IOut, Header, Verbose, Blank_At_Top, Blank_At_Bottom)</td></tr>
<tr class="memdesc:ae64f8cd347b0d00129d7fce3ea323c46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Print_Vector_Algebra1 is a subroutine used to print an MQC vector</b>  <a href="namespacemqc__algebra.html#ae64f8cd347b0d00129d7fce3ea323c46">More...</a><br /></td></tr>
<tr class="separator:ae64f8cd347b0d00129d7fce3ea323c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61df3eda09029cbe0513af750f9480a3"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a61df3eda09029cbe0513af750f9480a3">mqc_vector_cast_integer</a> (VA)</td></tr>
<tr class="memdesc:a61df3eda09029cbe0513af750f9480a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_vector_cast_integer is a function that converts an MQC vector to its integer space</b>  <a href="namespacemqc__algebra.html#a61df3eda09029cbe0513af750f9480a3">More...</a><br /></td></tr>
<tr class="separator:a61df3eda09029cbe0513af750f9480a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba4f662b816b4c95332885c0846548b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6ba4f662b816b4c95332885c0846548b">mqc_vector_cast_real</a> (VA)</td></tr>
<tr class="memdesc:a6ba4f662b816b4c95332885c0846548b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_vector_cast_real is a function that converts an MQC vector to its real space</b>  <a href="namespacemqc__algebra.html#a6ba4f662b816b4c95332885c0846548b">More...</a><br /></td></tr>
<tr class="separator:a6ba4f662b816b4c95332885c0846548b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a198620593d0a313eaff6785965b265"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a1a198620593d0a313eaff6785965b265">mqc_vector_cast_complex</a> (VA)</td></tr>
<tr class="memdesc:a1a198620593d0a313eaff6785965b265"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_vector_cast_complex is a function that converts an MQC vector to its complex space</b>  <a href="namespacemqc__algebra.html#a1a198620593d0a313eaff6785965b265">More...</a><br /></td></tr>
<tr class="separator:a1a198620593d0a313eaff6785965b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91796a634294803d77c56f70789ee4fe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a91796a634294803d77c56f70789ee4fe">mqc_vector_scalar_put</a> (Vector, Scalar, I)</td></tr>
<tr class="memdesc:a91796a634294803d77c56f70789ee4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Scalar_Put is a subroutine that updates the value of the ith element of a MQC vector with the value of a MQC scalar</b>  <a href="namespacemqc__algebra.html#a91796a634294803d77c56f70789ee4fe">More...</a><br /></td></tr>
<tr class="separator:a91796a634294803d77c56f70789ee4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5480b04f0bfad9017db7be94bdb335be"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5480b04f0bfad9017db7be94bdb335be">mqc_vector_scalar_increment</a> (Vector, Scalar, I)</td></tr>
<tr class="memdesc:a5480b04f0bfad9017db7be94bdb335be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Scalar_Increment is a subroutine that increments the value of the ith element of a MQC vector by the value of a MQC scalar</b>  <a href="namespacemqc__algebra.html#a5480b04f0bfad9017db7be94bdb335be">More...</a><br /></td></tr>
<tr class="separator:a5480b04f0bfad9017db7be94bdb335be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9783636b18868a1a9c6b22a0e057fd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a3b9783636b18868a1a9c6b22a0e057fd">mqc_vector_vector_put</a> (Vector, VectorIn, I)</td></tr>
<tr class="memdesc:a3b9783636b18868a1a9c6b22a0e057fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Vector_Put is a subroutine that updates the values of a subvector of a MQC vector with the values of a MQC vector</b>  <a href="namespacemqc__algebra.html#a3b9783636b18868a1a9c6b22a0e057fd">More...</a><br /></td></tr>
<tr class="separator:a3b9783636b18868a1a9c6b22a0e057fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fd19e8ff539e406535c3b241049d2f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a31fd19e8ff539e406535c3b241049d2f">mqc_vector_initialize</a> (Vector, Length, Scalar)</td></tr>
<tr class="memdesc:a31fd19e8ff539e406535c3b241049d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Initialize is a subroutine that initializes a MQC vector</b>  <a href="namespacemqc__algebra.html#a31fd19e8ff539e406535c3b241049d2f">More...</a><br /></td></tr>
<tr class="separator:a31fd19e8ff539e406535c3b241049d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5420193880824d24e30705966cab1a9b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5420193880824d24e30705966cab1a9b">mqc_scalarvectorproduct</a> (Scalar, Vector)</td></tr>
<tr class="memdesc:a5420193880824d24e30705966cab1a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarVectorProduct is a function that returns the product of a MQC scalar with a MQC vector</b>  <a href="namespacemqc__algebra.html#a5420193880824d24e30705966cab1a9b">More...</a><br /></td></tr>
<tr class="separator:a5420193880824d24e30705966cab1a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5722ad005cbbf566311c99db1f2dd8"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a9b5722ad005cbbf566311c99db1f2dd8">mqc_vectorscalarproduct</a> (vector, scalar)</td></tr>
<tr class="memdesc:a9b5722ad005cbbf566311c99db1f2dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorScalarProduct is a function that returns the product of a MQC vector with a MQC scalar</b>  <a href="namespacemqc__algebra.html#a9b5722ad005cbbf566311c99db1f2dd8">More...</a><br /></td></tr>
<tr class="separator:a9b5722ad005cbbf566311c99db1f2dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef893bc571f197a714a55d36dba87036"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aef893bc571f197a714a55d36dba87036">mqc_vectorscalardivide</a> (vector, scalar)</td></tr>
<tr class="memdesc:aef893bc571f197a714a55d36dba87036"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorScalarDivide is a function that returns a MQC vector divided by a MQC scalar</b>  <a href="namespacemqc__algebra.html#aef893bc571f197a714a55d36dba87036">More...</a><br /></td></tr>
<tr class="separator:aef893bc571f197a714a55d36dba87036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d6963c3e803f0a8a1487062c5551b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7b7d6963c3e803f0a8a1487062c5551b">mqc_realvectorproduct</a> (RealIn, Vector)</td></tr>
<tr class="memdesc:a7b7d6963c3e803f0a8a1487062c5551b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_RealVectorProduct is a function that returns the product of an <br  />
 intrinsic real scalar and a MQC vector</b>  <a href="namespacemqc__algebra.html#a7b7d6963c3e803f0a8a1487062c5551b">More...</a><br /></td></tr>
<tr class="separator:a7b7d6963c3e803f0a8a1487062c5551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaa76413201cc25b80779248460873e"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a0aaa76413201cc25b80779248460873e">mqc_vectorrealproduct</a> (vector, realIn)</td></tr>
<tr class="memdesc:a0aaa76413201cc25b80779248460873e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorRealProduct is a function that returns the product of a <br  />
 MQC vector and an intrinsic real scalar</b>  <a href="namespacemqc__algebra.html#a0aaa76413201cc25b80779248460873e">More...</a><br /></td></tr>
<tr class="separator:a0aaa76413201cc25b80779248460873e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d69a7fc334576aed2ba415df7bbc81"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a21d69a7fc334576aed2ba415df7bbc81">mqc_vectorrealdivide</a> (vector, realIn)</td></tr>
<tr class="memdesc:a21d69a7fc334576aed2ba415df7bbc81"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorRealDivide is a function that returns a MQC vector divided by an intrinsic real integer</b>  <a href="namespacemqc__algebra.html#a21d69a7fc334576aed2ba415df7bbc81">More...</a><br /></td></tr>
<tr class="separator:a21d69a7fc334576aed2ba415df7bbc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a9749c810a28c0cd1860548694b725"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a65a9749c810a28c0cd1860548694b725">mqc_integervectorproduct</a> (intIn, Vector)</td></tr>
<tr class="memdesc:a65a9749c810a28c0cd1860548694b725"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_IntegerVectorProduct is a function that returns the product of an intrinsic integer scalar and a MQC vector</b>  <a href="namespacemqc__algebra.html#a65a9749c810a28c0cd1860548694b725">More...</a><br /></td></tr>
<tr class="separator:a65a9749c810a28c0cd1860548694b725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43354fe746c522e4a4d5dcd3601d298"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa43354fe746c522e4a4d5dcd3601d298">mqc_vectorintegerproduct</a> (vector, intIn)</td></tr>
<tr class="memdesc:aa43354fe746c522e4a4d5dcd3601d298"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorIntegerProduct is a function that returns the product of a <br  />
 MQC vector and an intrinsic integer scalar</b>  <a href="namespacemqc__algebra.html#aa43354fe746c522e4a4d5dcd3601d298">More...</a><br /></td></tr>
<tr class="separator:aa43354fe746c522e4a4d5dcd3601d298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc6130ee8a14a99d0ee7be3460c5bb2"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6fc6130ee8a14a99d0ee7be3460c5bb2">mqc_vectorintegerdivide</a> (vector, intIn)</td></tr>
<tr class="memdesc:a6fc6130ee8a14a99d0ee7be3460c5bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorIntegerDivide is a function that returns a MQC vector divided by an intrinsic integer scalar</b>  <a href="namespacemqc__algebra.html#a6fc6130ee8a14a99d0ee7be3460c5bb2">More...</a><br /></td></tr>
<tr class="separator:a6fc6130ee8a14a99d0ee7be3460c5bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64aa274969f3fee2700a2f074d12ddb"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa64aa274969f3fee2700a2f074d12ddb">mqc_complexvectorproduct</a> (CompIn, Vector)</td></tr>
<tr class="memdesc:aa64aa274969f3fee2700a2f074d12ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ComplexVectorProduct is a function that returns the product of an intrinsic complex scalar and a MQC vector</b>  <a href="namespacemqc__algebra.html#aa64aa274969f3fee2700a2f074d12ddb">More...</a><br /></td></tr>
<tr class="separator:aa64aa274969f3fee2700a2f074d12ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2888851ed72ed54ca69d26140addcc5"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa2888851ed72ed54ca69d26140addcc5">mqc_vectorcomplexproduct</a> (vector, compIn)</td></tr>
<tr class="memdesc:aa2888851ed72ed54ca69d26140addcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorComplexProduct is a function that returns the product of a <br  />
 MQC vector and an intrinsic complex scalar</b>  <a href="namespacemqc__algebra.html#aa2888851ed72ed54ca69d26140addcc5">More...</a><br /></td></tr>
<tr class="separator:aa2888851ed72ed54ca69d26140addcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140f411d3c33c86dbcfe92574e4643f0"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a140f411d3c33c86dbcfe92574e4643f0">mqc_vectorcomplexdivide</a> (vector, compIn)</td></tr>
<tr class="memdesc:a140f411d3c33c86dbcfe92574e4643f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorComplexDivide is a function that returns a MQC vector divided by an intrinsic complex scalar</b>  <a href="namespacemqc__algebra.html#a140f411d3c33c86dbcfe92574e4643f0">More...</a><br /></td></tr>
<tr class="separator:a140f411d3c33c86dbcfe92574e4643f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe28acc2e8c2877cd034cb34218407a5"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#abe28acc2e8c2877cd034cb34218407a5">mqc_vector_norm</a> (vector, methodIn)</td></tr>
<tr class="memdesc:abe28acc2e8c2877cd034cb34218407a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Norm is a function that returns the norm of an MQC vector</b>  <a href="namespacemqc__algebra.html#abe28acc2e8c2877cd034cb34218407a5">More...</a><br /></td></tr>
<tr class="separator:abe28acc2e8c2877cd034cb34218407a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286a8b64267a598e6dcf03b66d0dbed3"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a286a8b64267a598e6dcf03b66d0dbed3">mqc_vector_isallocated</a> (Vector)</td></tr>
<tr class="memdesc:a286a8b64267a598e6dcf03b66d0dbed3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_isAllocated is a function that returns TRUE is an MQC vector is allocated and FALSE if it is not</b>  <a href="namespacemqc__algebra.html#a286a8b64267a598e6dcf03b66d0dbed3">More...</a><br /></td></tr>
<tr class="separator:a286a8b64267a598e6dcf03b66d0dbed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4440f8788b00f8527ef996e66361d45"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab4440f8788b00f8527ef996e66361d45">mqc_vector_push</a> (Vector, Scalar)</td></tr>
<tr class="memdesc:ab4440f8788b00f8527ef996e66361d45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Push is a function that adds a value to the end of a MQC vector</b>  <a href="namespacemqc__algebra.html#ab4440f8788b00f8527ef996e66361d45">More...</a><br /></td></tr>
<tr class="separator:ab4440f8788b00f8527ef996e66361d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d92908367908d5f07c2696808668da"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae1d92908367908d5f07c2696808668da">mqc_vector_unshift</a> (Vector, Scalar)</td></tr>
<tr class="memdesc:ae1d92908367908d5f07c2696808668da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Unshift is a function that adds a value to the beginning of a MQC vector</b>  <a href="namespacemqc__algebra.html#ae1d92908367908d5f07c2696808668da">More...</a><br /></td></tr>
<tr class="separator:ae1d92908367908d5f07c2696808668da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af293100432345fe20c1a1d501c0657aa"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af293100432345fe20c1a1d501c0657aa">mqc_vector_pop</a> (Vector)</td></tr>
<tr class="memdesc:af293100432345fe20c1a1d501c0657aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Pop is a function that removes a value from the end of a MQC vector and returns it</b>  <a href="namespacemqc__algebra.html#af293100432345fe20c1a1d501c0657aa">More...</a><br /></td></tr>
<tr class="separator:af293100432345fe20c1a1d501c0657aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854a27f3bcffbca9cdfe591a73faa501"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a854a27f3bcffbca9cdfe591a73faa501">mqc_vector_shift</a> (Vector)</td></tr>
<tr class="memdesc:a854a27f3bcffbca9cdfe591a73faa501"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Shift is a function that removes a value from the beginning of a MQC vector and returns it</b>  <a href="namespacemqc__algebra.html#a854a27f3bcffbca9cdfe591a73faa501">More...</a><br /></td></tr>
<tr class="separator:a854a27f3bcffbca9cdfe591a73faa501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc37e00be3bd370224f16b0695f5c07"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8dc37e00be3bd370224f16b0695f5c07">mqc_vector_maxval</a> (Vector)</td></tr>
<tr class="memdesc:a8dc37e00be3bd370224f16b0695f5c07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_MaxVal is a function that returns the largest value in <br  />
 an MQC vector</b>  <a href="namespacemqc__algebra.html#a8dc37e00be3bd370224f16b0695f5c07">More...</a><br /></td></tr>
<tr class="separator:a8dc37e00be3bd370224f16b0695f5c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcb11421e77fd4c0a249b0a2303eb9d"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aabcb11421e77fd4c0a249b0a2303eb9d">mqc_vector_minval</a> (Vector)</td></tr>
<tr class="memdesc:aabcb11421e77fd4c0a249b0a2303eb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_MinVal is a function that returns the smallest value in <br  />
 an MQC vector</b>  <a href="namespacemqc__algebra.html#aabcb11421e77fd4c0a249b0a2303eb9d">More...</a><br /></td></tr>
<tr class="separator:aabcb11421e77fd4c0a249b0a2303eb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf93471010696ea87f0b68274f32eebe"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#adf93471010696ea87f0b68274f32eebe">mqc_vector_maxloc</a> (Vector)</td></tr>
<tr class="memdesc:adf93471010696ea87f0b68274f32eebe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_MaxLoc is a function that returns the index of the largest value in an MQC vector</b>  <a href="namespacemqc__algebra.html#adf93471010696ea87f0b68274f32eebe">More...</a><br /></td></tr>
<tr class="separator:adf93471010696ea87f0b68274f32eebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46755babebe52ca491d14456a4e8596"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa46755babebe52ca491d14456a4e8596">mqc_vector_minloc</a> (Vector)</td></tr>
<tr class="memdesc:aa46755babebe52ca491d14456a4e8596"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_MinLoc is a function that returns the index of the smallest value in an MQC vector</b>  <a href="namespacemqc__algebra.html#aa46755babebe52ca491d14456a4e8596">More...</a><br /></td></tr>
<tr class="separator:aa46755babebe52ca491d14456a4e8596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453aaae4a21eac2ab290bcf63fca9137"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a453aaae4a21eac2ab290bcf63fca9137">mqc_vector_argsort</a> (Vector)</td></tr>
<tr class="memdesc:a453aaae4a21eac2ab290bcf63fca9137"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Argsort is a function that returns the indices of an an MQC vector sorted from low to high</b>  <a href="namespacemqc__algebra.html#a453aaae4a21eac2ab290bcf63fca9137">More...</a><br /></td></tr>
<tr class="separator:a453aaae4a21eac2ab290bcf63fca9137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e6a2d0e61a13ff688617643aafff21"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac6e6a2d0e61a13ff688617643aafff21">mqc_vector_sort</a> (Vector, idx)</td></tr>
<tr class="memdesc:ac6e6a2d0e61a13ff688617643aafff21"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Sort is a function that returns an MQC vector sorted from low to high unless optional index order is present</b>  <a href="namespacemqc__algebra.html#ac6e6a2d0e61a13ff688617643aafff21">More...</a><br /></td></tr>
<tr class="separator:ac6e6a2d0e61a13ff688617643aafff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c9d9461701d7c247ed0f4bd48a68ac"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac5c9d9461701d7c247ed0f4bd48a68ac">mqc_vector_sqrt</a> (A)</td></tr>
<tr class="memdesc:ac5c9d9461701d7c247ed0f4bd48a68ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Sqrt is a function that returns the square root of all elements of an MQC vector</b>  <a href="namespacemqc__algebra.html#ac5c9d9461701d7c247ed0f4bd48a68ac">More...</a><br /></td></tr>
<tr class="separator:ac5c9d9461701d7c247ed0f4bd48a68ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f8fcdd90b4dfb27df7aea1a5443aa6"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a06f8fcdd90b4dfb27df7aea1a5443aa6">mqc_vector_abs</a> (A)</td></tr>
<tr class="memdesc:a06f8fcdd90b4dfb27df7aea1a5443aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Abs is a function that returns the absolute value of all elements of an MQC vector</b>  <a href="namespacemqc__algebra.html#a06f8fcdd90b4dfb27df7aea1a5443aa6">More...</a><br /></td></tr>
<tr class="separator:a06f8fcdd90b4dfb27df7aea1a5443aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39efdd4b5c3a15ce5aa22df8e9a6de15"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a39efdd4b5c3a15ce5aa22df8e9a6de15">mqc_vector_power</a> (A, P)</td></tr>
<tr class="memdesc:a39efdd4b5c3a15ce5aa22df8e9a6de15"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Power is a function that returns the value of all elements of an MQC vector raised to a power</b>  <a href="namespacemqc__algebra.html#a39efdd4b5c3a15ce5aa22df8e9a6de15">More...</a><br /></td></tr>
<tr class="separator:a39efdd4b5c3a15ce5aa22df8e9a6de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455f7d692b63256f00e891310159eff5"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a455f7d692b63256f00e891310159eff5">mqc_vector_complex_realpart</a> (A)</td></tr>
<tr class="memdesc:a455f7d692b63256f00e891310159eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Complex_RealPart is a function that returns a MQC vector with elements containing the real part of elements of another MQC vector</b>  <a href="namespacemqc__algebra.html#a455f7d692b63256f00e891310159eff5">More...</a><br /></td></tr>
<tr class="separator:a455f7d692b63256f00e891310159eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f5b609f9905e81c158cfabc59ba995"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac0f5b609f9905e81c158cfabc59ba995">mqc_vector_complex_imagpart</a> (A)</td></tr>
<tr class="memdesc:ac0f5b609f9905e81c158cfabc59ba995"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Complex_ImagPart is a function that returns a MQC vector with elements containing the imaginary part of elements of another MQC vector</b>  <a href="namespacemqc__algebra.html#ac0f5b609f9905e81c158cfabc59ba995">More...</a><br /></td></tr>
<tr class="separator:ac0f5b609f9905e81c158cfabc59ba995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9392e173bbf919161ae62056ea02bc"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8d9392e173bbf919161ae62056ea02bc">mqc_vector_cmplx</a> (Vector1, Vector2)</td></tr>
<tr class="memdesc:a8d9392e173bbf919161ae62056ea02bc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector_Cmplx is a function that takes a MQC vector representing the real part and a MQC vector representing the imaginary part and combines them into another MQC vector</b>  <a href="namespacemqc__algebra.html#a8d9392e173bbf919161ae62056ea02bc">More...</a><br /></td></tr>
<tr class="separator:a8d9392e173bbf919161ae62056ea02bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3fb1ad2c32a7547cd2190e94769615"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#abf3fb1ad2c32a7547cd2190e94769615">mqc_matrix_diagonalize</a> (A, EVals, EVecs)</td></tr>
<tr class="memdesc:abf3fb1ad2c32a7547cd2190e94769615"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Diagonalize is a subroutine that takes a symmetric or hermitian MQC matrix and returns eigenvalues and eigenvectors</b>  <a href="namespacemqc__algebra.html#abf3fb1ad2c32a7547cd2190e94769615">More...</a><br /></td></tr>
<tr class="separator:abf3fb1ad2c32a7547cd2190e94769615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02da0d912f9a9741edd52654b908b08"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af02da0d912f9a9741edd52654b908b08">mqc_matrix_cast_real</a> (MA)</td></tr>
<tr class="memdesc:af02da0d912f9a9741edd52654b908b08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Cast_Real is a function that converts an MQC matrix to its real space</b>  <a href="namespacemqc__algebra.html#af02da0d912f9a9741edd52654b908b08">More...</a><br /></td></tr>
<tr class="separator:af02da0d912f9a9741edd52654b908b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261c99eae831fe640b991b32add18035"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a261c99eae831fe640b991b32add18035">mqc_matrix_cast_integer</a> (MA)</td></tr>
<tr class="memdesc:a261c99eae831fe640b991b32add18035"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Cast_Integer is a function that converts an MQC matrix to its integer space</b>  <a href="namespacemqc__algebra.html#a261c99eae831fe640b991b32add18035">More...</a><br /></td></tr>
<tr class="separator:a261c99eae831fe640b991b32add18035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59071347bd90e24767bccbd385218e2"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab59071347bd90e24767bccbd385218e2">mqc_matrix_cast_complex</a> (MA)</td></tr>
<tr class="memdesc:ab59071347bd90e24767bccbd385218e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Cast_Complex is a function that converts an MQC matrix to its complex space</b>  <a href="namespacemqc__algebra.html#ab59071347bd90e24767bccbd385218e2">More...</a><br /></td></tr>
<tr class="separator:ab59071347bd90e24767bccbd385218e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da4e494a21e7ea9e1fbd2198278e0ce"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6da4e494a21e7ea9e1fbd2198278e0ce">mqc_matrix_scalar_at</a> (Mat, I, J)</td></tr>
<tr class="memdesc:a6da4e494a21e7ea9e1fbd2198278e0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Scalar_At is a function that returns the value of an <br  />
 element of a MQC matrix</b>  <a href="namespacemqc__algebra.html#a6da4e494a21e7ea9e1fbd2198278e0ce">More...</a><br /></td></tr>
<tr class="separator:a6da4e494a21e7ea9e1fbd2198278e0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6928e084da14a1fb181ab7e264fda37c"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6928e084da14a1fb181ab7e264fda37c">mqc_matrix_vector_at</a> (Mat, Rows, Cols)</td></tr>
<tr class="memdesc:a6928e084da14a1fb181ab7e264fda37c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Vector_At is a function that returns the subvector of an <br  />
 MQC matrix</b>  <a href="namespacemqc__algebra.html#a6928e084da14a1fb181ab7e264fda37c">More...</a><br /></td></tr>
<tr class="separator:a6928e084da14a1fb181ab7e264fda37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72ca45faf635b0f22318fdc8ac957b9"><td class="memItemLeft" align="right" valign="top">recursive subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac72ca45faf635b0f22318fdc8ac957b9">mqc_matrix_vector_put</a> (Mat, VectorIn, Rows, Cols)</td></tr>
<tr class="memdesc:ac72ca45faf635b0f22318fdc8ac957b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Vector_Put is a subroutine that writes a subvector to the specified position of a MQC matrix</b>  <a href="namespacemqc__algebra.html#ac72ca45faf635b0f22318fdc8ac957b9">More...</a><br /></td></tr>
<tr class="separator:ac72ca45faf635b0f22318fdc8ac957b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3609569bc7a7c48d424c657d141cd5ef"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a3609569bc7a7c48d424c657d141cd5ef">mqc_matrix_matrix_at</a> (Mat, Rows, Cols)</td></tr>
<tr class="memdesc:a3609569bc7a7c48d424c657d141cd5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Matrix_At is a function that returns a submatrix of the matrix</b>  <a href="namespacemqc__algebra.html#a3609569bc7a7c48d424c657d141cd5ef">More...</a><br /></td></tr>
<tr class="separator:a3609569bc7a7c48d424c657d141cd5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5190dd4e0b311022233f28e391bd51bb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5190dd4e0b311022233f28e391bd51bb">mqc_matrix_diagmatrix_put_vector</a> (diagVectorIn, mat)</td></tr>
<tr class="memdesc:a5190dd4e0b311022233f28e391bd51bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_DiagMatrix_Put_Vector is a subroutine that returns a diagonal MQC matrix with elements defined by values in a MQC vector</b>  <a href="namespacemqc__algebra.html#a5190dd4e0b311022233f28e391bd51bb">More...</a><br /></td></tr>
<tr class="separator:a5190dd4e0b311022233f28e391bd51bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4a934665cdcc5c99684b62046cf303"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a9b4a934665cdcc5c99684b62046cf303">mqc_matrix_diagmatrix_put_integer</a> (mat, diagMatrixIn)</td></tr>
<tr class="memdesc:a9b4a934665cdcc5c99684b62046cf303"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_DiagMatrix_Put_integer is a subroutine that returns a diagonal MQC matrix with elements defined by values in an intrinsic integer vector</b>  <a href="namespacemqc__algebra.html#a9b4a934665cdcc5c99684b62046cf303">More...</a><br /></td></tr>
<tr class="separator:a9b4a934665cdcc5c99684b62046cf303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51dfe98702e34c1aea85c65afd8d2be"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac51dfe98702e34c1aea85c65afd8d2be">mqc_matrix_diagmatrix_put_real</a> (mat, diagMatrixIn)</td></tr>
<tr class="memdesc:ac51dfe98702e34c1aea85c65afd8d2be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_DiagMatrix_Put_Real is a subroutine that returns a diagonal MQC matrix with elements defined by values in an intrinsic real vector</b>  <a href="namespacemqc__algebra.html#ac51dfe98702e34c1aea85c65afd8d2be">More...</a><br /></td></tr>
<tr class="separator:ac51dfe98702e34c1aea85c65afd8d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0257675a8f879d16d7d730aabfcb6496"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a0257675a8f879d16d7d730aabfcb6496">mqc_matrix_diagmatrix_put_complex</a> (mat, diagMatrixIn)</td></tr>
<tr class="memdesc:a0257675a8f879d16d7d730aabfcb6496"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_DiagMatrix_Put_Complex is a subroutine that returns a diagonal MQC matrix with elements defined by values in an intrinsic complex vector</b>  <a href="namespacemqc__algebra.html#a0257675a8f879d16d7d730aabfcb6496">More...</a><br /></td></tr>
<tr class="separator:a0257675a8f879d16d7d730aabfcb6496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874218f3a41af94853ebfed27a74f27f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a874218f3a41af94853ebfed27a74f27f">mqc_matrix_symmmatrix_put_integer</a> (mat, symmMatrixIn)</td></tr>
<tr class="memdesc:a874218f3a41af94853ebfed27a74f27f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_SymmMatrix_Put_Integer is a subroutine that returns a symmetric packed MQC matrix with elements defined by values in an intrinsic integer vector</b>  <a href="namespacemqc__algebra.html#a874218f3a41af94853ebfed27a74f27f">More...</a><br /></td></tr>
<tr class="separator:a874218f3a41af94853ebfed27a74f27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04d32e23c58f1a14085b5f3fa9e9f5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7d04d32e23c58f1a14085b5f3fa9e9f5">mqc_matrix_symmmatrix_put_real</a> (mat, symmMatrixIn)</td></tr>
<tr class="memdesc:a7d04d32e23c58f1a14085b5f3fa9e9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_SymmMatrix_Put_Real is a subroutine that returns a symmetric packed MQC matrix with elements defined by values in an intrinsic real vector</b>  <a href="namespacemqc__algebra.html#a7d04d32e23c58f1a14085b5f3fa9e9f5">More...</a><br /></td></tr>
<tr class="separator:a7d04d32e23c58f1a14085b5f3fa9e9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540647c8ae1cb6741daad88911807139"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a540647c8ae1cb6741daad88911807139">mqc_matrix_symmmatrix_put_complex</a> (mat, symmMatrixIn)</td></tr>
<tr class="memdesc:a540647c8ae1cb6741daad88911807139"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_SymmMatrix_Put_Complex is a subroutine that returns a symmetric packed MQC matrix with elements defined by values in an intrinsic complex vector</b>  <a href="namespacemqc__algebra.html#a540647c8ae1cb6741daad88911807139">More...</a><br /></td></tr>
<tr class="separator:a540647c8ae1cb6741daad88911807139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228aa4094ce52274a2a6e3d2b40c78a3"><td class="memItemLeft" align="right" valign="top">recursive subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a228aa4094ce52274a2a6e3d2b40c78a3">mqc_matrix_matrix_put</a> (Mat, MatrixIn, Rows, Cols)</td></tr>
<tr class="memdesc:a228aa4094ce52274a2a6e3d2b40c78a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Matrix_Put is a subroutine that writes a submatrix to the specified position of a MQC matrix</b>  <a href="namespacemqc__algebra.html#a228aa4094ce52274a2a6e3d2b40c78a3">More...</a><br /></td></tr>
<tr class="separator:a228aa4094ce52274a2a6e3d2b40c78a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62b00883eb990030317e03cc38e4c44"><td class="memItemLeft" align="right" valign="top">integer(kind=int64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af62b00883eb990030317e03cc38e4c44">symindexhash</a> (i, j, k, l)</td></tr>
<tr class="memdesc:af62b00883eb990030317e03cc38e4c44"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> SymIndexHash is a function that returns the index in a vector of a symmetric-packed matrix or rank-4 tensor</b>  <a href="namespacemqc__algebra.html#af62b00883eb990030317e03cc38e4c44">More...</a><br /></td></tr>
<tr class="separator:af62b00883eb990030317e03cc38e4c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee02d698f2778caa5357ac832bacbee"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#adee02d698f2778caa5357ac832bacbee">mqc_elementmatrixproduct</a> (A, B)</td></tr>
<tr class="memdesc:adee02d698f2778caa5357ac832bacbee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ElementMatrixProduct is a function that returns the element- wise product of two MQC matrices</b>  <a href="namespacemqc__algebra.html#adee02d698f2778caa5357ac832bacbee">More...</a><br /></td></tr>
<tr class="separator:adee02d698f2778caa5357ac832bacbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b737940649403205e5b4c28e6ac74b5"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6b737940649403205e5b4c28e6ac74b5">mqc_elementmatrixdivide</a> (A, B)</td></tr>
<tr class="memdesc:a6b737940649403205e5b4c28e6ac74b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ElementMatrixDivide is a function that returns the element- wise quotient of two MQC matrices</b>  <a href="namespacemqc__algebra.html#a6b737940649403205e5b4c28e6ac74b5">More...</a><br /></td></tr>
<tr class="separator:a6b737940649403205e5b4c28e6ac74b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa84c562aa9933eead2de01256e418d"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aefa84c562aa9933eead2de01256e418d">mqc_matrix_test_symmetric</a> (Matrix, Option)</td></tr>
<tr class="memdesc:aefa84c562aa9933eead2de01256e418d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Test_Symmetric is a function that tests a MQC matrix for symmetry</b>  <a href="namespacemqc__algebra.html#aefa84c562aa9933eead2de01256e418d">More...</a><br /></td></tr>
<tr class="separator:aefa84c562aa9933eead2de01256e418d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad61cf37cde19aa4f02ffaf341995d0"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6ad61cf37cde19aa4f02ffaf341995d0">mqc_matrix_test_diagonal</a> (Matrix)</td></tr>
<tr class="memdesc:a6ad61cf37cde19aa4f02ffaf341995d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Test_Diagonal is a function that tests a MQC matrix to determine if it is diagonal</b>  <a href="namespacemqc__algebra.html#a6ad61cf37cde19aa4f02ffaf341995d0">More...</a><br /></td></tr>
<tr class="separator:a6ad61cf37cde19aa4f02ffaf341995d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65657601eed2d5c49b47cd302397ac7d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a65657601eed2d5c49b47cd302397ac7d">mqc_allocate_matrix</a> (M, N, Matrix, Data_Type, Storage)</td></tr>
<tr class="memdesc:a65657601eed2d5c49b47cd302397ac7d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Allocate_Matrix is used to allocate a matrix type variable of the MQC_Matrix class</b>  <a href="namespacemqc__algebra.html#a65657601eed2d5c49b47cd302397ac7d">More...</a><br /></td></tr>
<tr class="separator:a65657601eed2d5c49b47cd302397ac7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38699b65c769a92dc2cb0b85de9f6705"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a38699b65c769a92dc2cb0b85de9f6705">mqc_deallocate_matrix</a> (Matrix)</td></tr>
<tr class="memdesc:a38699b65c769a92dc2cb0b85de9f6705"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Deallocate_Matrix is used to deallocate a matrix type variable of the MQC_Matrix class</b>  <a href="namespacemqc__algebra.html#a38699b65c769a92dc2cb0b85de9f6705">More...</a><br /></td></tr>
<tr class="separator:a38699b65c769a92dc2cb0b85de9f6705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840d2395f096fc5c91c22b627f610e2b"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a840d2395f096fc5c91c22b627f610e2b">mqc_matrix_isallocated</a> (Matrix)</td></tr>
<tr class="memdesc:a840d2395f096fc5c91c22b627f610e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_isAllocate is a function that returns the allocation status of a MQC_Matrix variable</b>  <a href="namespacemqc__algebra.html#a840d2395f096fc5c91c22b627f610e2b">More...</a><br /></td></tr>
<tr class="separator:a840d2395f096fc5c91c22b627f610e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d7a2397ab1d86b82d757a197137ab7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a20d7a2397ab1d86b82d757a197137ab7">mqc_set_integerarray2matrix</a> (MatrixOut, ArrayIn)</td></tr>
<tr class="memdesc:a20d7a2397ab1d86b82d757a197137ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_IntegerArray2Matrix is a subroutine that sets an MQC matrix equal to an intrinsic integer rank-2 array</b>  <a href="namespacemqc__algebra.html#a20d7a2397ab1d86b82d757a197137ab7">More...</a><br /></td></tr>
<tr class="separator:a20d7a2397ab1d86b82d757a197137ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac220bbbae4694f6402442c9155322869"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac220bbbae4694f6402442c9155322869">mqc_set_realarray2matrix</a> (MatrixOut, ArrayIn)</td></tr>
<tr class="memdesc:ac220bbbae4694f6402442c9155322869"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_RealArray2Matrix is a subroutine that sets an MQC matrix equal to an intrinsic real rank-2 array</b>  <a href="namespacemqc__algebra.html#ac220bbbae4694f6402442c9155322869">More...</a><br /></td></tr>
<tr class="separator:ac220bbbae4694f6402442c9155322869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a5a36d7be18f1b190240fd8a7ab81e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae9a5a36d7be18f1b190240fd8a7ab81e">mqc_set_complexarray2matrix</a> (MatrixOut, ArrayIn)</td></tr>
<tr class="memdesc:ae9a5a36d7be18f1b190240fd8a7ab81e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_ComplexArray2Matrix is a subroutine that sets an MQC matrix equal to an intrinsic complex rank-2 array</b>  <a href="namespacemqc__algebra.html#ae9a5a36d7be18f1b190240fd8a7ab81e">More...</a><br /></td></tr>
<tr class="separator:ae9a5a36d7be18f1b190240fd8a7ab81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8204520d32c6bfe3cee8aa2d50b65274"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8204520d32c6bfe3cee8aa2d50b65274">mqc_set_matrix2integerarray</a> (ArrayOut, MatrixIn)</td></tr>
<tr class="memdesc:a8204520d32c6bfe3cee8aa2d50b65274"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Matrix2IntegerArray is a subroutine that sets an intrinsic integer rank-2 array equal to an MQC matrix</b>  <a href="namespacemqc__algebra.html#a8204520d32c6bfe3cee8aa2d50b65274">More...</a><br /></td></tr>
<tr class="separator:a8204520d32c6bfe3cee8aa2d50b65274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544f1ff194490228f18d7198a4baeecc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a544f1ff194490228f18d7198a4baeecc">mqc_set_matrix2realarray</a> (ArrayOut, MatrixIn)</td></tr>
<tr class="memdesc:a544f1ff194490228f18d7198a4baeecc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Matrix2RealArray is a subroutine that sets an intrinsic real rank-2 array equal to an MQC matrix</b>  <a href="namespacemqc__algebra.html#a544f1ff194490228f18d7198a4baeecc">More...</a><br /></td></tr>
<tr class="separator:a544f1ff194490228f18d7198a4baeecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99c5a9550ff2979949b3f89070f6afb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab99c5a9550ff2979949b3f89070f6afb">mqc_set_matrix2complexarray</a> (ArrayOut, MatrixIn)</td></tr>
<tr class="memdesc:ab99c5a9550ff2979949b3f89070f6afb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Matrix2ComplexArray is a subroutine that sets an intrinsic complex rank-2 array equal to an MQC matrix</b>  <a href="namespacemqc__algebra.html#ab99c5a9550ff2979949b3f89070f6afb">More...</a><br /></td></tr>
<tr class="separator:ab99c5a9550ff2979949b3f89070f6afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a783566c4891b64f8e83fee736ba20"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a15a783566c4891b64f8e83fee736ba20">mqc_set_matrix2matrix</a> (MatrixOut, MatrixIn)</td></tr>
<tr class="memdesc:a15a783566c4891b64f8e83fee736ba20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Set_Matrix2Matrix is a subroutine that sets an MQC matrix equal to another MQC matrix</b>  <a href="namespacemqc__algebra.html#a15a783566c4891b64f8e83fee736ba20">More...</a><br /></td></tr>
<tr class="separator:a15a783566c4891b64f8e83fee736ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f6e2214dff5439ec0aa9d6202a40ab"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a18f6e2214dff5439ec0aa9d6202a40ab">mqc_print_matrix_algebra1</a> (Matrix, IOut, Header, Blank_At_Top, Blank_At_Bottom)</td></tr>
<tr class="memdesc:a18f6e2214dff5439ec0aa9d6202a40ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Print_Matrix_Algebra1 is a subroutine used to print an MQC matrix</b>  <a href="namespacemqc__algebra.html#a18f6e2214dff5439ec0aa9d6202a40ab">More...</a><br /></td></tr>
<tr class="separator:a18f6e2214dff5439ec0aa9d6202a40ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0d58bbdb51cd77e8f62ac4a9afc2ec"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a5e0d58bbdb51cd77e8f62ac4a9afc2ec">mqc_matrix_copy_int2real</a> (Matrix)</td></tr>
<tr class="memdesc:a5e0d58bbdb51cd77e8f62ac4a9afc2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Copy_Int2Real is a subroutine used to copy an integer MQC matrix into its real space</b>  <a href="namespacemqc__algebra.html#a5e0d58bbdb51cd77e8f62ac4a9afc2ec">More...</a><br /></td></tr>
<tr class="separator:a5e0d58bbdb51cd77e8f62ac4a9afc2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625f6cf3e3b057fc28da2edc3b79e2fb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a625f6cf3e3b057fc28da2edc3b79e2fb">mqc_matrix_copy_int2complex</a> (Matrix)</td></tr>
<tr class="memdesc:a625f6cf3e3b057fc28da2edc3b79e2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Copy_Int2Complex is a subroutine used to copy an integer MQC matrix into its complex space</b>  <a href="namespacemqc__algebra.html#a625f6cf3e3b057fc28da2edc3b79e2fb">More...</a><br /></td></tr>
<tr class="separator:a625f6cf3e3b057fc28da2edc3b79e2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad968ae4927598763a4772bacc5d0ad7f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ad968ae4927598763a4772bacc5d0ad7f">mqc_matrix_copy_real2int</a> (Matrix)</td></tr>
<tr class="memdesc:ad968ae4927598763a4772bacc5d0ad7f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Copy_Real2Int is a subroutine used to copy a real MQC matrix into its integer space</b>  <a href="namespacemqc__algebra.html#ad968ae4927598763a4772bacc5d0ad7f">More...</a><br /></td></tr>
<tr class="separator:ad968ae4927598763a4772bacc5d0ad7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfde0b3b95688c4788930ee3c1077a1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aacfde0b3b95688c4788930ee3c1077a1">mqc_matrix_copy_real2complex</a> (Matrix)</td></tr>
<tr class="memdesc:aacfde0b3b95688c4788930ee3c1077a1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Copy_Real2Complex is a subroutine used to copy a real MQC matrix into its complex space</b>  <a href="namespacemqc__algebra.html#aacfde0b3b95688c4788930ee3c1077a1">More...</a><br /></td></tr>
<tr class="separator:aacfde0b3b95688c4788930ee3c1077a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67d18eea5dd9bab9ebce77a53c09f74"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af67d18eea5dd9bab9ebce77a53c09f74">mqc_matrix_copy_complex2int</a> (Matrix)</td></tr>
<tr class="memdesc:af67d18eea5dd9bab9ebce77a53c09f74"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Copy_Complex2Int is a subroutine used to copy a complex MQC matrix into its integer space</b>  <a href="namespacemqc__algebra.html#af67d18eea5dd9bab9ebce77a53c09f74">More...</a><br /></td></tr>
<tr class="separator:af67d18eea5dd9bab9ebce77a53c09f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0132d9cc98355602a93c17beb7858c5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa0132d9cc98355602a93c17beb7858c5">mqc_matrix_copy_complex2real</a> (Matrix)</td></tr>
<tr class="memdesc:aa0132d9cc98355602a93c17beb7858c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Copy_Complex2Real is a subroutine used to copy a complex MQC matrix into its real space</b>  <a href="namespacemqc__algebra.html#aa0132d9cc98355602a93c17beb7858c5">More...</a><br /></td></tr>
<tr class="separator:aa0132d9cc98355602a93c17beb7858c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ba8f0a20ce59677fd7cad2a9e24bf7"><td class="memItemLeft" align="right" valign="top">integer(kind=int64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a51ba8f0a20ce59677fd7cad2a9e24bf7">mqc_matrix_rows</a> (Matrix)</td></tr>
<tr class="memdesc:a51ba8f0a20ce59677fd7cad2a9e24bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Rows is a function used to return the number of rows of an MQC matrix</b>  <a href="namespacemqc__algebra.html#a51ba8f0a20ce59677fd7cad2a9e24bf7">More...</a><br /></td></tr>
<tr class="separator:a51ba8f0a20ce59677fd7cad2a9e24bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5926a9911e81c54d4fd9c1f15dfa27"><td class="memItemLeft" align="right" valign="top">integer(kind=int64) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a1f5926a9911e81c54d4fd9c1f15dfa27">mqc_matrix_columns</a> (Matrix)</td></tr>
<tr class="memdesc:a1f5926a9911e81c54d4fd9c1f15dfa27"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Columns is a function used to return the number of columns of an MQC matrix</b>  <a href="namespacemqc__algebra.html#a1f5926a9911e81c54d4fd9c1f15dfa27">More...</a><br /></td></tr>
<tr class="separator:a1f5926a9911e81c54d4fd9c1f15dfa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acade87107ad17f989be91301553df8a6"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#acade87107ad17f989be91301553df8a6">mqc_matrix_havereal</a> (Matrix)</td></tr>
<tr class="memdesc:acade87107ad17f989be91301553df8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_HaveReal is a function used to indicate if an MQC matrix has an allocated real matrix</b>  <a href="namespacemqc__algebra.html#acade87107ad17f989be91301553df8a6">More...</a><br /></td></tr>
<tr class="separator:acade87107ad17f989be91301553df8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29bf4c1d5435e97d9763a04291c65d0"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aa29bf4c1d5435e97d9763a04291c65d0">mqc_matrix_haveinteger</a> (Matrix)</td></tr>
<tr class="memdesc:aa29bf4c1d5435e97d9763a04291c65d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_HaveInteger is a function used to indicate if an MQC matrix has an allocated integer matrix</b>  <a href="namespacemqc__algebra.html#aa29bf4c1d5435e97d9763a04291c65d0">More...</a><br /></td></tr>
<tr class="separator:aa29bf4c1d5435e97d9763a04291c65d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b79e988ed88206c28f8d43db5029873"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a9b79e988ed88206c28f8d43db5029873">mqc_matrix_havecomplex</a> (Matrix)</td></tr>
<tr class="memdesc:a9b79e988ed88206c28f8d43db5029873"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_HaveComplex is a function used to indicate if an MQC matrix has an allocated complex matrix</b>  <a href="namespacemqc__algebra.html#a9b79e988ed88206c28f8d43db5029873">More...</a><br /></td></tr>
<tr class="separator:a9b79e988ed88206c28f8d43db5029873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2725ea9543a7f168e193039f993ec53"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#af2725ea9543a7f168e193039f993ec53">mqc_matrix_havefull</a> (Matrix)</td></tr>
<tr class="memdesc:af2725ea9543a7f168e193039f993ec53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_HaveFull is a function used to indicate if an MQC matrix is stored unpacked</b>  <a href="namespacemqc__algebra.html#af2725ea9543a7f168e193039f993ec53">More...</a><br /></td></tr>
<tr class="separator:af2725ea9543a7f168e193039f993ec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8207ccd518cdc6fb476fb8d178db53"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7c8207ccd518cdc6fb476fb8d178db53">mqc_matrix_havesymmetric</a> (Matrix)</td></tr>
<tr class="memdesc:a7c8207ccd518cdc6fb476fb8d178db53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_HaveSymmetric is a function used to indicate if an MQC matrix is stored symmetric-packed</b>  <a href="namespacemqc__algebra.html#a7c8207ccd518cdc6fb476fb8d178db53">More...</a><br /></td></tr>
<tr class="separator:a7c8207ccd518cdc6fb476fb8d178db53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d16caed4314c658cf5d2b7ccb28bbb8"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a3d16caed4314c658cf5d2b7ccb28bbb8">mqc_matrix_havediagonal</a> (Matrix)</td></tr>
<tr class="memdesc:a3d16caed4314c658cf5d2b7ccb28bbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_HaveDiagonal is a function used to indicate if an MQC matrix is stored diagonal-packed</b>  <a href="namespacemqc__algebra.html#a3d16caed4314c658cf5d2b7ccb28bbb8">More...</a><br /></td></tr>
<tr class="separator:a3d16caed4314c658cf5d2b7ccb28bbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dc9a6d8c03968a055211b3d9b1f105"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a60dc9a6d8c03968a055211b3d9b1f105">mqc_matrix_transpose</a> (Matrix)</td></tr>
<tr class="memdesc:a60dc9a6d8c03968a055211b3d9b1f105"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Transpose is a function that returns the transpose of a MQC matrix</b>  <a href="namespacemqc__algebra.html#a60dc9a6d8c03968a055211b3d9b1f105">More...</a><br /></td></tr>
<tr class="separator:a60dc9a6d8c03968a055211b3d9b1f105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c797b90ca3c4ad265a9d463a6570345"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a4c797b90ca3c4ad265a9d463a6570345">mqc_matrix_conjugate_transpose</a> (Matrix)</td></tr>
<tr class="memdesc:a4c797b90ca3c4ad265a9d463a6570345"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Conjugate_Transpose is a function that returns the conjugate transpose of a MQC matrix</b>  <a href="namespacemqc__algebra.html#a4c797b90ca3c4ad265a9d463a6570345">More...</a><br /></td></tr>
<tr class="separator:a4c797b90ca3c4ad265a9d463a6570345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac797640c3e0bb06f8fdf7be857845957"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac797640c3e0bb06f8fdf7be857845957">mqc_matrix_symmetrize</a> (Matrix)</td></tr>
<tr class="memdesc:ac797640c3e0bb06f8fdf7be857845957"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Symmetrize is a function that symmetrizes a MQC matrix</b>  <a href="namespacemqc__algebra.html#ac797640c3e0bb06f8fdf7be857845957">More...</a><br /></td></tr>
<tr class="separator:ac797640c3e0bb06f8fdf7be857845957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef463820abe4650a2faeac78e0f4b4f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#abef463820abe4650a2faeac78e0f4b4f">mqc_matrix_full2symm</a> (Matrix)</td></tr>
<tr class="memdesc:abef463820abe4650a2faeac78e0f4b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Full2Symm is a subroutine that converts an unpacked MQC matrix to symmetric-packed</b>  <a href="namespacemqc__algebra.html#abef463820abe4650a2faeac78e0f4b4f">More...</a><br /></td></tr>
<tr class="separator:abef463820abe4650a2faeac78e0f4b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5ef28f290e4f9f1ce51fe154d91533"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a3b5ef28f290e4f9f1ce51fe154d91533">mqc_matrix_symm2full</a> (Matrix, Option)</td></tr>
<tr class="memdesc:a3b5ef28f290e4f9f1ce51fe154d91533"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Symm2Full is a subroutine that converts a symmetry-packed MQC matrix to unpacked</b>  <a href="namespacemqc__algebra.html#a3b5ef28f290e4f9f1ce51fe154d91533">More...</a><br /></td></tr>
<tr class="separator:a3b5ef28f290e4f9f1ce51fe154d91533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92516c8d0a56a9f5b159c5674e5c60f1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a92516c8d0a56a9f5b159c5674e5c60f1">mqc_matrix_full2diag</a> (Matrix)</td></tr>
<tr class="memdesc:a92516c8d0a56a9f5b159c5674e5c60f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Full2Diag is a subroutine that converts an unpacked MQC matrix to diagonal-packed</b>  <a href="namespacemqc__algebra.html#a92516c8d0a56a9f5b159c5674e5c60f1">More...</a><br /></td></tr>
<tr class="separator:a92516c8d0a56a9f5b159c5674e5c60f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17baee9e5f8b7a841edc786ab481a7e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae17baee9e5f8b7a841edc786ab481a7e">mqc_matrix_diag2full</a> (Matrix)</td></tr>
<tr class="memdesc:ae17baee9e5f8b7a841edc786ab481a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Diag2Full is a subroutine that converts a diagonal-packed MQC matrix to unpacked</b>  <a href="namespacemqc__algebra.html#ae17baee9e5f8b7a841edc786ab481a7e">More...</a><br /></td></tr>
<tr class="separator:ae17baee9e5f8b7a841edc786ab481a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8fe92d1f31abbeb4c23127776581c3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#adb8fe92d1f31abbeb4c23127776581c3">mqc_matrix_symm2diag</a> (Matrix)</td></tr>
<tr class="memdesc:adb8fe92d1f31abbeb4c23127776581c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Symm2Diag is a subroutine that converts a symmetry-packed MQC matrix to diagonal-packed</b>  <a href="namespacemqc__algebra.html#adb8fe92d1f31abbeb4c23127776581c3">More...</a><br /></td></tr>
<tr class="separator:adb8fe92d1f31abbeb4c23127776581c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8aee67ccafeb86b35959d1ce1e7da4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8a8aee67ccafeb86b35959d1ce1e7da4">mqc_matrix_diag2symm</a> (Matrix)</td></tr>
<tr class="memdesc:a8a8aee67ccafeb86b35959d1ce1e7da4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Diag2Symm is a subroutine that converts a diagonal-packed MQC matrix to symmetry-packed</b>  <a href="namespacemqc__algebra.html#a8a8aee67ccafeb86b35959d1ce1e7da4">More...</a><br /></td></tr>
<tr class="separator:a8a8aee67ccafeb86b35959d1ce1e7da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3898fe4dcc387ce87913df99da20cb"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#adf3898fe4dcc387ce87913df99da20cb">mqc_matrix_symm2full_func</a> (Matrix)</td></tr>
<tr class="memdesc:adf3898fe4dcc387ce87913df99da20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Symm2Full_Func is a function that converts a symmetric- packed MQC matrix to unpacked</b>  <a href="namespacemqc__algebra.html#adf3898fe4dcc387ce87913df99da20cb">More...</a><br /></td></tr>
<tr class="separator:adf3898fe4dcc387ce87913df99da20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe4f3ba2ca89b46415e29454b92f0cd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aabe4f3ba2ca89b46415e29454b92f0cd">matrix_symm2sq_integer</a> (N, I_Symm, I_Sq)</td></tr>
<tr class="memdesc:aabe4f3ba2ca89b46415e29454b92f0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Matrix_Symm2Sq_Integer is a subroutine that converts a symmetric- packed intrinsic integer matrix to a rank-2 intrinsic integer array</b>  <a href="namespacemqc__algebra.html#aabe4f3ba2ca89b46415e29454b92f0cd">More...</a><br /></td></tr>
<tr class="separator:aabe4f3ba2ca89b46415e29454b92f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f2cca04b517c21d664ad38af52afb0"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac6f2cca04b517c21d664ad38af52afb0">matrix_symm2sq_real</a> (N, A_Symm, A_Sq)</td></tr>
<tr class="memdesc:ac6f2cca04b517c21d664ad38af52afb0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Matrix_Symm2Sq_Real is a subroutine that converts a symmetric- packed intrinsic real matrix to a rank-2 intrinsic real array</b>  <a href="namespacemqc__algebra.html#ac6f2cca04b517c21d664ad38af52afb0">More...</a><br /></td></tr>
<tr class="separator:ac6f2cca04b517c21d664ad38af52afb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade03ba6fbf76d8c6dafc56f07a187d5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aade03ba6fbf76d8c6dafc56f07a187d5">matrix_symm2sq_complex</a> (N, A_Symm, A_Sq)</td></tr>
<tr class="memdesc:aade03ba6fbf76d8c6dafc56f07a187d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> Matrix_Symm2Sq_Complex is a subroutine that converts a symmetric- packed intrinsic complex matrix to a rank-2 intrinsic complex array</b>  <a href="namespacemqc__algebra.html#aade03ba6fbf76d8c6dafc56f07a187d5">More...</a><br /></td></tr>
<tr class="separator:aade03ba6fbf76d8c6dafc56f07a187d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8156b61ed2a139980ac838ddb4bf66a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab8156b61ed2a139980ac838ddb4bf66a">mqc_vector2diagmatrix</a> (vector)</td></tr>
<tr class="memdesc:ab8156b61ed2a139980ac838ddb4bf66a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Vector2DiagMatrix is a function that outputs a diagonal MQC matrix with elements defined by an MQC vector</b>  <a href="namespacemqc__algebra.html#ab8156b61ed2a139980ac838ddb4bf66a">More...</a><br /></td></tr>
<tr class="separator:ab8156b61ed2a139980ac838ddb4bf66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80828c415886bec8f4bda38064f7366c"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a80828c415886bec8f4bda38064f7366c">mqc_matrixmatrixsum</a> (MA, MB)</td></tr>
<tr class="memdesc:a80828c415886bec8f4bda38064f7366c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_MatrixMatrixSum is a function that sums two MQC matrices</b>  <a href="namespacemqc__algebra.html#a80828c415886bec8f4bda38064f7366c">More...</a><br /></td></tr>
<tr class="separator:a80828c415886bec8f4bda38064f7366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645e3425761f5a431b864ba730d7a2a7"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a645e3425761f5a431b864ba730d7a2a7">mqc_matrixmatrixsubtract</a> (MA, MB)</td></tr>
<tr class="memdesc:a645e3425761f5a431b864ba730d7a2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_MatrixMatrixSubtract is a function that subtracts two MQC matrices</b>  <a href="namespacemqc__algebra.html#a645e3425761f5a431b864ba730d7a2a7">More...</a><br /></td></tr>
<tr class="separator:a645e3425761f5a431b864ba730d7a2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447b09386b734386f15489c647a89a1b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a447b09386b734386f15489c647a89a1b">mqc_matrixmatrixproduct</a> (MA, MB)</td></tr>
<tr class="memdesc:a447b09386b734386f15489c647a89a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_MatrixMatrixProduct is a function that computes the element- wise product of two MQC matrices</b>  <a href="namespacemqc__algebra.html#a447b09386b734386f15489c647a89a1b">More...</a><br /></td></tr>
<tr class="separator:a447b09386b734386f15489c647a89a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3603ce30c98db8c2332c2a41803d9e9"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab3603ce30c98db8c2332c2a41803d9e9">mqc_matrixmatrixdotproduct</a> (MA, MB)</td></tr>
<tr class="memdesc:ab3603ce30c98db8c2332c2a41803d9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_MatrixMatrixDotProduct is a function that computes the inner product of two MQC matrices</b>  <a href="namespacemqc__algebra.html#ab3603ce30c98db8c2332c2a41803d9e9">More...</a><br /></td></tr>
<tr class="separator:ab3603ce30c98db8c2332c2a41803d9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0f266a7c3eff1a58e31758e1da31d"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8bf0f266a7c3eff1a58e31758e1da31d">mqc_matrixvectordotproduct</a> (MA, VB)</td></tr>
<tr class="memdesc:a8bf0f266a7c3eff1a58e31758e1da31d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_MatrixVectorDotProduct is a function that computes the inner product of a MQC matrix and a MQC vector</b>  <a href="namespacemqc__algebra.html#a8bf0f266a7c3eff1a58e31758e1da31d">More...</a><br /></td></tr>
<tr class="separator:a8bf0f266a7c3eff1a58e31758e1da31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb0ed524675a362b716b280e5221a40"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7fb0ed524675a362b716b280e5221a40">mqc_vectormatrixdotproduct</a> (VA, MB)</td></tr>
<tr class="memdesc:a7fb0ed524675a362b716b280e5221a40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_VectorMatrixDotProduct is a function that computes the inner product of a MQC vector and a MQC matrix</b>  <a href="namespacemqc__algebra.html#a7fb0ed524675a362b716b280e5221a40">More...</a><br /></td></tr>
<tr class="separator:a7fb0ed524675a362b716b280e5221a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf13b444bd513d0fec9ec1842dd11ca"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#aedf13b444bd513d0fec9ec1842dd11ca">mqc_matrixscalarproduct</a> (Matrix, Scalar)</td></tr>
<tr class="memdesc:aedf13b444bd513d0fec9ec1842dd11ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_MatrixScalarProduct is a function that computes the product of a MQC scalar and a MQC matrix</b>  <a href="namespacemqc__algebra.html#aedf13b444bd513d0fec9ec1842dd11ca">More...</a><br /></td></tr>
<tr class="separator:aedf13b444bd513d0fec9ec1842dd11ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f25321d9656a01ab64b54e3b44663f0"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a0f25321d9656a01ab64b54e3b44663f0">mqc_scalarmatrixproduct</a> (Scalar, Matrix)</td></tr>
<tr class="memdesc:a0f25321d9656a01ab64b54e3b44663f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_ScalarMatrixProduct is a function that computes the product of a MQC matrix and a MQC scalar</b>  <a href="namespacemqc__algebra.html#a0f25321d9656a01ab64b54e3b44663f0">More...</a><br /></td></tr>
<tr class="separator:a0f25321d9656a01ab64b54e3b44663f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8e01e798119d66ffffb76c632be635"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#acc8e01e798119d66ffffb76c632be635">mqc_matrix_matrix_contraction</a> (Matrix1, Matrix2)</td></tr>
<tr class="memdesc:acc8e01e798119d66ffffb76c632be635"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Matrix_Contraction is a function that returns the contraction of two MQC matrices</b>  <a href="namespacemqc__algebra.html#acc8e01e798119d66ffffb76c632be635">More...</a><br /></td></tr>
<tr class="separator:acc8e01e798119d66ffffb76c632be635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0a2b8295316e1ff182faea150106fc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a7a0a2b8295316e1ff182faea150106fc">mqc_matrix_scalar_put</a> (Matrix, Scalar, I, J)</td></tr>
<tr class="memdesc:a7a0a2b8295316e1ff182faea150106fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Scalar_Put is a subroutine that updates the value of the (i,j)th element of a MQC matrix</b>  <a href="namespacemqc__algebra.html#a7a0a2b8295316e1ff182faea150106fc">More...</a><br /></td></tr>
<tr class="separator:a7a0a2b8295316e1ff182faea150106fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad443d560d370221484c3c57a10aac2b4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ad443d560d370221484c3c57a10aac2b4">mqc_matrix_initialize</a> (Matrix, Rows, Columns, Scalar, Storage)</td></tr>
<tr class="memdesc:ad443d560d370221484c3c57a10aac2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Initialize is a subroutine that initializes an MQC matrix with each element equal to a chosen value</b>  <a href="namespacemqc__algebra.html#ad443d560d370221484c3c57a10aac2b4">More...</a><br /></td></tr>
<tr class="separator:ad443d560d370221484c3c57a10aac2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec9bcc90cf10ad8fe36cecbc373bb5c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#acec9bcc90cf10ad8fe36cecbc373bb5c">mqc_matrix_identity</a> (matrix, n, m)</td></tr>
<tr class="memdesc:acec9bcc90cf10ad8fe36cecbc373bb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Identity is a subroutine that initializes an MQC matrix as an identity matrix</b>  <a href="namespacemqc__algebra.html#acec9bcc90cf10ad8fe36cecbc373bb5c">More...</a><br /></td></tr>
<tr class="separator:acec9bcc90cf10ad8fe36cecbc373bb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f816bab517aac5d63f5d9b8ed02dd18"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8f816bab517aac5d63f5d9b8ed02dd18">mqc_matrix_set</a> (matrix, scalar, storage)</td></tr>
<tr class="memdesc:a8f816bab517aac5d63f5d9b8ed02dd18"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Set is a subroutine that sets an MQC matrix to a value without resizing its dimensions</b>  <a href="namespacemqc__algebra.html#a8f816bab517aac5d63f5d9b8ed02dd18">More...</a><br /></td></tr>
<tr class="separator:a8f816bab517aac5d63f5d9b8ed02dd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dde5f99073fe3cf79e23acca3e987d"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a55dde5f99073fe3cf79e23acca3e987d">mqc_matrix_norm</a> (matrix, methodIn)</td></tr>
<tr class="memdesc:a55dde5f99073fe3cf79e23acca3e987d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Norm is a function that returns the norm of an MQC matrix</b>  <a href="namespacemqc__algebra.html#a55dde5f99073fe3cf79e23acca3e987d">More...</a><br /></td></tr>
<tr class="separator:a55dde5f99073fe3cf79e23acca3e987d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66208198c831733979379bd8f085f6d7"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a66208198c831733979379bd8f085f6d7">mqc_matrix_determinant</a> (a)</td></tr>
<tr class="memdesc:a66208198c831733979379bd8f085f6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Determinant is a function that returns the determinant of an MQC matrix</b>  <a href="namespacemqc__algebra.html#a66208198c831733979379bd8f085f6d7">More...</a><br /></td></tr>
<tr class="separator:a66208198c831733979379bd8f085f6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794d5bfc83a321363fdef81d521af07"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a8794d5bfc83a321363fdef81d521af07">mqc_matrix_inverse</a> (a)</td></tr>
<tr class="memdesc:a8794d5bfc83a321363fdef81d521af07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Inverse is a function that returns the inverse of an MQC matrix</b>  <a href="namespacemqc__algebra.html#a8794d5bfc83a321363fdef81d521af07">More...</a><br /></td></tr>
<tr class="separator:a8794d5bfc83a321363fdef81d521af07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ede23293575f7658fd5fa6cdd47e9"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab79ede23293575f7658fd5fa6cdd47e9">mqc_matrix_trace</a> (matrix)</td></tr>
<tr class="memdesc:ab79ede23293575f7658fd5fa6cdd47e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Trace is a function that returns the trace of an MQC matrix</b>  <a href="namespacemqc__algebra.html#ab79ede23293575f7658fd5fa6cdd47e9">More...</a><br /></td></tr>
<tr class="separator:ab79ede23293575f7658fd5fa6cdd47e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648e057f051a2d1538eccb5ea846c711"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a648e057f051a2d1538eccb5ea846c711">mqc_matrix_generalized_eigensystem</a> (a, bIn, eigenvals, reigenvecs, leigenvecs)</td></tr>
<tr class="memdesc:a648e057f051a2d1538eccb5ea846c711"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Generalized_Eigensystem is a subroutine that takes a MQC matrix and a metric and returns eigenvalues and eigenvectors</b>  <a href="namespacemqc__algebra.html#a648e057f051a2d1538eccb5ea846c711">More...</a><br /></td></tr>
<tr class="separator:a648e057f051a2d1538eccb5ea846c711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf0a09beb557ab60485c31b884790ff"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6bf0a09beb557ab60485c31b884790ff">mqc_matrix_svd</a> (A, EVals, EUVecs, EVVecs)</td></tr>
<tr class="memdesc:a6bf0a09beb557ab60485c31b884790ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_SVD is a subroutine that computes the singular value decomposition of a MQC matrix</b>  <a href="namespacemqc__algebra.html#a6bf0a09beb557ab60485c31b884790ff">More...</a><br /></td></tr>
<tr class="separator:a6bf0a09beb557ab60485c31b884790ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d3af3c878fdc1247f135ee8bf7cae9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ad9d3af3c878fdc1247f135ee8bf7cae9">mqc_matrix_rms_max</a> (A, rms_A, max_A)</td></tr>
<tr class="memdesc:ad9d3af3c878fdc1247f135ee8bf7cae9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_RMS_Max is a subroutine that returns the RMS and maximum values of a MQC matrix</b>  <a href="namespacemqc__algebra.html#ad9d3af3c878fdc1247f135ee8bf7cae9">More...</a><br /></td></tr>
<tr class="separator:ad9d3af3c878fdc1247f135ee8bf7cae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20713aedbc2621c6649a8ab0d26c411"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae20713aedbc2621c6649a8ab0d26c411">mqc_matrix_sqrt</a> (A, eVals, eVecs)</td></tr>
<tr class="memdesc:ae20713aedbc2621c6649a8ab0d26c411"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Matrix_Sqrt is a subroutine that returns the square root of a MQC matrix</b>  <a href="namespacemqc__algebra.html#ae20713aedbc2621c6649a8ab0d26c411">More...</a><br /></td></tr>
<tr class="separator:ae20713aedbc2621c6649a8ab0d26c411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92156d28df8cfc2b045169751beaa35a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a92156d28df8cfc2b045169751beaa35a">mqc_givens_matrix</a> (m_size, angle, p, q)</td></tr>
<tr class="memdesc:a92156d28df8cfc2b045169751beaa35a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> MQC_Givens_Matrix is a function that outputs a Givens rotation matrix of specified angle and vector pair as an MQC matrix</b>  <a href="namespacemqc__algebra.html#a92156d28df8cfc2b045169751beaa35a">More...</a><br /></td></tr>
<tr class="separator:a92156d28df8cfc2b045169751beaa35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a32a5ad12790b27e6ac97416516ebe"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ad2a32a5ad12790b27e6ac97416516ebe">mqc_allocate_r4tensor</a> (I, J, K, L, Tensor, Data_Type, Storage)</td></tr>
<tr class="separator:ad2a32a5ad12790b27e6ac97416516ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0fe8ac26fa70fc7257b03a208e3cc4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6a0fe8ac26fa70fc7257b03a208e3cc4">mqc_deallocate_r4tensor</a> (Tensor)</td></tr>
<tr class="separator:a6a0fe8ac26fa70fc7257b03a208e3cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8dd8de2a67def6b122ae5cd47a7c62"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a6e8dd8de2a67def6b122ae5cd47a7c62">mqc_r4tensor_at</a> (Tensor, I, J, K, L)</td></tr>
<tr class="separator:a6e8dd8de2a67def6b122ae5cd47a7c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74124faccbf37cc34cd219065c146b1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ab74124faccbf37cc34cd219065c146b1">mqc_r4tensor_put</a> (Tensor, Element, I, J, K, L)</td></tr>
<tr class="separator:ab74124faccbf37cc34cd219065c146b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5aa22c14da0bd4a866e2370b36d9fc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#abf5aa22c14da0bd4a866e2370b36d9fc">mqc_print_r4tensor_algebra1</a> (Tensor, IOut, Header, blank_at_top, blank_at_bottom)</td></tr>
<tr class="separator:abf5aa22c14da0bd4a866e2370b36d9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dc9134fedc47e63403ea816ad243cd"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a21dc9134fedc47e63403ea816ad243cd">mqc_set_array2tensor</a> (TensorOut, ArrayIn)</td></tr>
<tr class="separator:a21dc9134fedc47e63403ea816ad243cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5d378d98af2e37361a7c88d69ea155"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a9f5d378d98af2e37361a7c88d69ea155">mqc_r4tensor_initialize</a> (R4Tensor, I, J, K, L, Scalar)</td></tr>
<tr class="separator:a9f5d378d98af2e37361a7c88d69ea155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d068f8df321ac955582abba9f6a684"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a12d068f8df321ac955582abba9f6a684">mqc_matrix_symmsymmr4tensor_put_real</a> (r4Tensor, symmSymmMatrixIn)</td></tr>
<tr class="separator:a12d068f8df321ac955582abba9f6a684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae168e90d957c7858f3e46cee806587c3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae168e90d957c7858f3e46cee806587c3">mqc_matrix_symmsymmr4tensor_put_complex</a> (r4Tensor, symmSymmMatrixIn)</td></tr>
<tr class="separator:ae168e90d957c7858f3e46cee806587c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148537e9a896894b25e159753c262704"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#a148537e9a896894b25e159753c262704">mqc_r4tensor_haveinteger</a> (R4Tensor)</td></tr>
<tr class="separator:a148537e9a896894b25e159753c262704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f03e88192b3cf9f2a561bdf8b479c"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ae34f03e88192b3cf9f2a561bdf8b479c">mqc_r4tensor_havereal</a> (R4Tensor)</td></tr>
<tr class="separator:ae34f03e88192b3cf9f2a561bdf8b479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac546a96a95d1f312446237d53d3c0b1c"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemqc__algebra.html#ac546a96a95d1f312446237d53d3c0b1c">mqc_r4tensor_havecomplex</a> (R4Tensor)</td></tr>
<tr class="separator:ac546a96a95d1f312446237d53d3c0b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b> MQC Algebra contains mathematical objects that are designed to simplify and automate variable use in Fortran </b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC Algebra contains mathematical objects that are designed to simplify
    and automate variable use in Fortran. Arrays can be packed for efficient 
    memory use and used for operations completely transparently to the user. 
    Furthermore, there is no need to type arrays, as this can be manipulated 
    on the fly. Arrays carry their own procedures, and use underlying lapack 
    routines for efficiency. The MQC derivd types defined in this package 
    are:

    1. MQC_Scalar:   Rank 0 array variable
    2. MQC_Vector:   Rank 1 array variable
    3. MQC_Matrix:   Rank 2 array variable
    4. MQC_R4Tensor: Rank 3 array variable

    This module is level 1 in the MQC hierarchy and so depends on level 0
    modules. 

    Note that MQC_Algebra2 provides similar functionality with MQC_Array 
    objects that can dynamically adjust rank. However, the vast majority of 
    work can be performed using MQC_Algebra derived types which have been 
    more developed than MQC_Algebra2 derived types.</pre> </dd></dl>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="ac8599e5948deb641a1debb6531a3ed30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8599e5948deb641a1debb6531a3ed30">&#9670;&nbsp;</a></span>bin_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind=int64) function mqc_algebra::bin_coeff </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Bin_Coeff returns the binomial coefficient of (n,k)</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    Bin_Coeff is a function that returns the binomial coefficient given input
    integer N and input integer K corresponding to N choose K.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        The number of objects.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">        K is Integer(kind=int64) 
        The number of permutations.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="af43924c79b927084f5776417442fabac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43924c79b927084f5776417442fabac">&#9670;&nbsp;</a></span>factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind=int64) function mqc_algebra::factorial </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Factorial returns the factorial of an integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    Factorial is a function that returns the factorial of an integer.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        The argument of the factorial function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="aade03ba6fbf76d8c6dafc56f07a187d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade03ba6fbf76d8c6dafc56f07a187d5">&#9670;&nbsp;</a></span>matrix_symm2sq_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::matrix_symm2sq_complex </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>A_Symm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>A_Sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Matrix_Symm2Sq_Complex is a subroutine that converts a symmetric- packed intrinsic complex matrix to a rank-2 intrinsic complex array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    Matrix_Symm2Sq_Complex is a subroutine that converts a symmetric-packed 
    intrinsic complex matrix to a rank-2 complex array.
    TODO: Move this routine to MQC general</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        The leading dimension of symmetric-packed matrix I_Symm.
        unpacked.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_Symm</td><td><pre class="fragment">        A_Symm is Complex(kind=real64),Dimension(:)
        The symmetric-packed intrinsic complex matrix to be 
        unpacked.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_Sq</td><td><pre class="fragment">        A_Sq is Complex(kind=real64),Dimension(N,N)
        The upacked intrinsic complex matrix output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aabe4f3ba2ca89b46415e29454b92f0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe4f3ba2ca89b46415e29454b92f0cd">&#9670;&nbsp;</a></span>matrix_symm2sq_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::matrix_symm2sq_integer </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>I_Symm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>I_Sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Matrix_Symm2Sq_Integer is a subroutine that converts a symmetric- packed intrinsic integer matrix to a rank-2 intrinsic integer array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    Matrix_Symm2Sq_Integer is a subroutine that converts a symmetric-packed 
    intrinsic integer matrix to a rank-2 integer array.
    TODO: Move this routine to MQC general</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        The leading dimension of symmetric-packed matrix I_Symm.
        unpacked.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I_Symm</td><td><pre class="fragment">        I_Symm is Integer(kind=int64),Dimension(:)
        The symmetric-packed intrinsic integer matrix to be unpacked.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I_Sq</td><td><pre class="fragment">        I_Sq is Integer(kind=int64),Dimension(N,N)
        The upacked intrinsic integer matrix output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ac6f2cca04b517c21d664ad38af52afb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f2cca04b517c21d664ad38af52afb0">&#9670;&nbsp;</a></span>matrix_symm2sq_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::matrix_symm2sq_real </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>A_Symm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(n,n), intent(out)&#160;</td>
          <td class="paramname"><em>A_Sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> Matrix_Symm2Sq_Real is a subroutine that converts a symmetric- packed intrinsic real matrix to a rank-2 intrinsic real array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    Matrix_Symm2Sq_Real is a subroutine that converts a symmetric-packed 
    intrinsic real matrix to a rank-2 real array.
    TODO: Move this routine to MQC general</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        The leading dimension of symmetric-packed matrix I_Symm.
        unpacked.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_Symm</td><td><pre class="fragment">        A_Symm is Real(kind=real64),Dimension(:)
        The symmetric-packed intrinsic real matrix to be unpacked.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_Sq</td><td><pre class="fragment">        A_Sq is Real(kind=real64),Dimension(N,N)
        The upacked intrinsic real matrix output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a65657601eed2d5c49b47cd302397ac7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65657601eed2d5c49b47cd302397ac7d">&#9670;&nbsp;</a></span>mqc_allocate_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_allocate_matrix </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Data_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Allocate_Matrix is used to allocate a matrix type variable of the MQC_Matrix class</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Allocate_Matrix is a subroutine used to allocate a matrix type variable
    of the MQC_Matrix class. The following options are available:

    1. Data_Type = 'Real' declares the MQC_Matrix variable to be of real type. 
    2. Data_Type = 'Integer' declares the MQC_Matrix variable to be of integer type.
    3. Data_Type = 'Complex' declares the MQC_Matrix variable to be of complex type.
    1. Data_Type = 'StorFull' declares the MQC_Matrix variable to be unpacked.
    2. Data_Type = 'StorSymm' declares the MQC_Matrix variable to be symmetric packed.
    3. Data_Type = 'StorDiag' declares the MQC_Matrix variable to be diagonal packed.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">        M is Integer(kind=int64)
        M is the number of rows of Matrix. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        N is the number of columns of Matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The MQC matrix to be allocated.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data_Type</td><td><pre class="fragment">        Data_Type is Character(Len=*)
        = 'Real':    the MQC_Scalar is real
        = 'Integer': the MQC_Scalar is integer
        = 'Complex': the MQC_Scalar is complex.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Storage</td><td><br  />
 <pre class="fragment">        Storage is Character(Len=*)
        = 'StorFull': the MQC_Scalar is unpacked
        = 'StorSymm': the MQC_Scalar is symmetric packed
        = 'StorDiag': the MQC_Scalar is diagonal packed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd>
<dd>
L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ad2a32a5ad12790b27e6ac97416516ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a32a5ad12790b27e6ac97416516ebe">&#9670;&nbsp;</a></span>mqc_allocate_r4tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_allocate_r4tensor </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Data_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fab0b12181034281f017537a4adf730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab0b12181034281f017537a4adf730">&#9670;&nbsp;</a></span>mqc_allocate_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_allocate_scalar </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Data_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Allocate_Scalar is used to allocate a scalar type variable of the MQC_Scalar class</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Allocate_Scalar is a subroutine used to allocate a scalar type variable
    of the MQC_Scalar class. The following options are available:

    1. Data_Type = 'Real' declares the MQC_Scalar variable to be of real type. 
    2. Data_Type = 'Integer' declares the MQC_Scalar variable to be of integer type.
    3. Data_Type = 'Complex' declares the MQC_Scalar variable to be of complex type.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The name of the MQC_Scalar variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data_Type</td><td><pre class="fragment">        Data_Type is Character(Len=*)
        = 'Real':    the MQC_Scalar is real
        = 'Integer': the MQC_Scalar is integer
        = 'Complex': the MQC_Scalar is complex.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a43d6ff5efede7d1a15a1d31b11500bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d6ff5efede7d1a15a1d31b11500bd2">&#9670;&nbsp;</a></span>mqc_allocate_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_allocate_vector </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Data_Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Allocate_Vector is used to allocate a vector type variable of the MQC_Vector class</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Allocate_Vector is a subroutine used to allocate a vector type variable
    of the MQC_Vector class. The following options are available:

    1. Data_Type = 'Real' declares the MQC_Vector variable to be of real type. 
    2. Data_Type = 'Integer' declares the MQC_Vector variable to be of integer type.
    3. Data_Type = 'Complex' declares the MQC_Vector variable to be of complex type.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        The length of the MQC_Vector variable</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The name of the MQC_Vector variable</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Data_Type</td><td><pre class="fragment">        Data_Type is Character(Len=*)
        = 'Real':    the MQC_Vector is real
        = 'Integer': the MQC_Vector is integer
        = 'Complex': the MQC_Vector is complex</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a808c0cb549729a735e76fb23a224b6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808c0cb549729a735e76fb23a224b6fe">&#9670;&nbsp;</a></span>mqc_complexscalaradd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_complexscalaradd </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ComplexScalarAdd is a function that is used to sum an intrinsic complex by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ComplexScalarAdd is a function that is used to sum an intrinsic complex by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        Complex is Complex(kind=real64)
        The intrinsic complex variable to sum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variabel to sum.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ac43b6ab656657a60c626d3ce59599414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43b6ab656657a60c626d3ce59599414">&#9670;&nbsp;</a></span>mqc_complexscalardivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_complexscalardivide </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ComplexScalarDivide is a function that is used to divide an intrinsic complex by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ComplexScalarDivide is a function that is used to divide an intrinsic complex by an
    MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        ComplexIn is Complex(kind=real64)
        The intrinsic complex variable numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="accff0ad4fff7388aa7ec919e750b39c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accff0ad4fff7388aa7ec919e750b39c1">&#9670;&nbsp;</a></span>mqc_complexscalarmultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_complexscalarmultiply </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ComplexScalarMultiply is a function that is used to multiply an intrinsic complex by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ComplexScalarMultiply is a function that is used to multiply an intrinsic complex by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        Complex is Complex(kind=real64)
        The intrinsic complex variable to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variabel to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ab1eb7c31e42137f86753c430312dfbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1eb7c31e42137f86753c430312dfbc5">&#9670;&nbsp;</a></span>mqc_complexscalarsubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_complexscalarsubtract </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ComplexScalarSubtract is a function that is used to subtract an MQC_Scalar from an intrinisic complex</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ComplexScalarSubtract is a function that is used to subtract an MQC_Scalar from an
    intrinisic complex. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        ComplexIn is Complex(kind=real64)
        The intrinsic complex to subtract from.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to subtract.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="aa64aa274969f3fee2700a2f074d12ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64aa274969f3fee2700a2f074d12ddb">&#9670;&nbsp;</a></span>mqc_complexvectorproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_complexvectorproduct </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>CompIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ComplexVectorProduct is a function that returns the product of an intrinsic complex scalar and a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ComplexVectorProduct is a function that returns the product of an intrinsic 
    integer scalar and a MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CompIn</td><td><pre class="fragment">        CompIn is Complex(kind=real64)
        The intrinsic complex to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="af1d8e1c15eb8c2bef8793e3fbb0b9d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d8e1c15eb8c2bef8793e3fbb0b9d11">&#9670;&nbsp;</a></span>mqc_crossproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_crossproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector1In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector2In</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_CrossProduct is a function that returns the cross product of two MQC vectors</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_CrossProduct is a function that returns the cross product of two MQC 
    vectors. The vectors should both be of length 3.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector1In</td><td><pre class="fragment">        Vector1In is Type(MQC_Vector)
        The first MQC vector. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector2In</td><td><pre class="fragment">        Vector2In is Type(MQC_Vector)
        The second MQC vector. </pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a38699b65c769a92dc2cb0b85de9f6705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38699b65c769a92dc2cb0b85de9f6705">&#9670;&nbsp;</a></span>mqc_deallocate_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_deallocate_matrix </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Deallocate_Matrix is used to deallocate a matrix type variable of the MQC_Matrix class</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Deallocate_Matrix is a subroutine used to deallocate a matrix type variable
    of the MQC_Matrix class. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The MQC matrix to be deallocated.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a6a0fe8ac26fa70fc7257b03a208e3cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0fe8ac26fa70fc7257b03a208e3cc4">&#9670;&nbsp;</a></span>mqc_deallocate_r4tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_deallocate_r4tensor </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae22ac4f8d222ab896734ad93e99b7ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22ac4f8d222ab896734ad93e99b7ebe">&#9670;&nbsp;</a></span>mqc_deallocate_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_deallocate_scalar </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Deallocate_Scalar is used to deallocate a scalar type variable of the MQC_Scalar class</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Deallocate_Scalar is a subroutine used to deallocate a scalar type variable
    of the MQC_Scalar class. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The name of the MQC_Scalar variable to deallocate.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="aabeb2fe8ce3cd32371c13b18f8609df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeb2fe8ce3cd32371c13b18f8609df2">&#9670;&nbsp;</a></span>mqc_deallocate_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_deallocate_vector </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Deallocate_Vector is used to deallocate a vector type variable of the MQC_Vector class</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Deallocate_Vector is a subroutine used to deallocate a vector type variable
    of the MQC_Vector class. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The name of the MQC_Vector variable to deallocate.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a6b737940649403205e5b4c28e6ac74b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b737940649403205e5b4c28e6ac74b5">&#9670;&nbsp;</a></span>mqc_elementmatrixdivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_elementmatrixdivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ElementMatrixDivide is a function that returns the element- wise quotient of two MQC matrices</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ElementMatrixDivide is a function that returns the element-wise quotient 
    of two MQC matrices.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is type(mqc_matrix)
        The matrix with elements being the numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">        B is type(mqc_matrix)
        The matrix with elements being the denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="adee02d698f2778caa5357ac832bacbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee02d698f2778caa5357ac832bacbee">&#9670;&nbsp;</a></span>mqc_elementmatrixproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_elementmatrixproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ElementMatrixProduct is a function that returns the element- wise product of two MQC matrices</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ElementMatrixProduct is a function that returns the element-wise product 
    of two MQC matrices.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is type(mqc_matrix)
        The first matrix to element-wise multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td><pre class="fragment">        B is type(mqc_matrix)
        The second matrix to element-wise multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a577ba023f29432f58832d1cc6e29e182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577ba023f29432f58832d1cc6e29e182">&#9670;&nbsp;</a></span>mqc_elementvectorproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_elementvectorproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector1In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector2In</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ElementVectorProduct is a function that multiplies two MQC vectors elementwise and stores them into another MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ElementVectorProduct is a function that multiplies two MQC vectors 
    elementwise and stores them into another MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector1In</td><td><pre class="fragment">        Vector1In is Type(MQC_Vector)
        The frist MQC vector to multiply elementwise.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector2In</td><td><pre class="fragment">        Vector2In is Type(MQC_Vector)
        The second MQC vector to multiply elementwise.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a92156d28df8cfc2b045169751beaa35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92156d28df8cfc2b045169751beaa35a">&#9670;&nbsp;</a></span>mqc_givens_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_givens_matrix </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>m_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Givens_Matrix is a function that outputs a Givens rotation matrix of specified angle and vector pair as an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Givens_Matrix is a function that outputs a Givens rotation matrix of 
    specified angle and vector pair as an MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M_Size</td><td><pre class="fragment">        M_Size is integer(kind=int64)
        The dimension of the Givens matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Angle</td><td><pre class="fragment">        Angle is real(kind=real64)
        The angle of rotation in radians.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">        P is integer(kind=int64)
        The first vector to rotate.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td><pre class="fragment">        Q is integer(kind=int64)
        The second vector to rotate.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>A. D. Mahler <br  />
 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a469678aed0f067aa78822a8fad2cf3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469678aed0f067aa78822a8fad2cf3be">&#9670;&nbsp;</a></span>mqc_input_complex_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_input_complex_scalar </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>ScalarOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Input_Complex_Scalar is a subroutine is used to set an intrinsic complex to an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Input_Complex_Scalar is a subroutine is used to set an intrinsic complex to an MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScalarOut</td><td><pre class="fragment">        ScalarOut is Type(MQC_Scalar)
        The name of the output variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Complex(kind=real64) 
        The value of the input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ac8ff0afb694c02c897dc47299aad8fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ff0afb694c02c897dc47299aad8fad">&#9670;&nbsp;</a></span>mqc_input_integer_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_input_integer_scalar </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>ScalarOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Input_Integer_Scalar is a subroutine is used to set an intrinsic integer to an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Input_Integer_Scalar is a subroutine is used to set an intrinsic integer to an MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScalarOut</td><td><pre class="fragment">        ScalarOut is Type(MQC_Scalar)
        The name of the output variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Integer(kind=int64) 
        The value of the input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a5523039fa283a160a967555f3983ed1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5523039fa283a160a967555f3983ed1d">&#9670;&nbsp;</a></span>mqc_input_real_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_input_real_scalar </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>ScalarOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Input_Real_Scalar is a subroutine is used to set an intrinsic real to an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Input_Integer_Scalar is a subroutine is used to set an intrinsic real to an MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScalarOut</td><td><pre class="fragment">        ScalarOut is Type(MQC_Scalar)
        The name of the output variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Real(kind=real64) 
        The value of the input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ae88b633e98529241ac0027699711cff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88b633e98529241ac0027699711cff4">&#9670;&nbsp;</a></span>mqc_integergtscalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_integergtscalar </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_IntegerGTScalar is a function that returns TRUE if an intrinsic integer is greater than a MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_IntegerGTScalar is a function that returns TRUE if an intrinsic integer is greater 
    than a MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the intrinsic integer 
    is greater than the real part of the MQC_Scalar and FALSE if the intrinsic integer is 
    less than the real part of the MQC_Scalar. If the intrinsic integer is equal to the
    real part of the MQC_Scalar, the function returns TRUE if the imaginary part of 
    MQC_Scalar is less than zero and FALSE otherwise. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The intrinsic integer that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="abdd72b97a1b34f869365e71dcc031af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd72b97a1b34f869365e71dcc031af5">&#9670;&nbsp;</a></span>mqc_integerlescalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_integerlescalar </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_IntegerLEScalar is a function that returns TRUE if an intrinsic integer is less than or equal to a MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_IntegerLEScalar is a function that returns TRUE if an intrinsic integer is less 
    than or equal to a MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the intrinsic integer 
    is less than or equal to the real part of the MQC_Scalar and FALSE if the intrinsic 
    integer is greater than the real part of the MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The intrinsic integer that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a07ce708060612d891456764837300437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce708060612d891456764837300437">&#9670;&nbsp;</a></span>mqc_integerscalaradd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_integerscalaradd </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_IntegerScalarAdd is a function that is used to multiply an intrinsic integer by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_IntegerScalarAdd is a function that is used to sum an intrinsic integer by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer variable to sum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to sum.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a51aeec216cc444858a35ab2a50f4c069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51aeec216cc444858a35ab2a50f4c069">&#9670;&nbsp;</a></span>mqc_integerscalardivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_integerscalardivide </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_IntegerScalarDivide is a function that is used to divide an intrinsic integer by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_IntegerScalarDivide is a function that is used to divide an intrinsic integer by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer variable numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a0611c528322a72b23eedfb2fcfa0b5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0611c528322a72b23eedfb2fcfa0b5cd">&#9670;&nbsp;</a></span>mqc_integerscalarmultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_integerscalarmultiply </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_IntegerScalarMultiply is a function that is used to multiply an intrinsic integer by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_IntegerScalarMultiply is a function that is used to multiply an intrinsic integer by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer variable to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a8441269618f9fb27d9c6b96f44401e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8441269618f9fb27d9c6b96f44401e23">&#9670;&nbsp;</a></span>mqc_integerscalarsubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_integerscalarsubtract </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_IntegerScalarSubtract is a function that is used to subtract an MQC_Scalar from an intrinisic integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_IntegerScalarSubtract is a function that is used to subtract an MQC_Scalar from an
    intrinisic integer. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer to subtract from.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to subtract.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a65a9749c810a28c0cd1860548694b725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a9749c810a28c0cd1860548694b725">&#9670;&nbsp;</a></span>mqc_integervectorproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_integervectorproduct </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>intIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_IntegerVectorProduct is a function that returns the product of an intrinsic integer scalar and a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_IntegerVectorProduct is a function that returns the product of an intrinsic 
    integer scalar and a MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The intrinsic integer to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a8914aee32665a30481184250b3cb0d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8914aee32665a30481184250b3cb0d96">&#9670;&nbsp;</a></span>mqc_length_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind=int64) function mqc_algebra::mqc_length_vector </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Length_Vector is used to return the length of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Length_Vector is used to return the length of an MQC vector. If the vector
    vector is NOT allocated, the length is returned as 0. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The name of the MQC_Vector variable whose length will be returned. </pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ab59071347bd90e24767bccbd385218e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59071347bd90e24767bccbd385218e2">&#9670;&nbsp;</a></span>mqc_matrix_cast_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_cast_complex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Cast_Complex is a function that converts an MQC matrix to its complex space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Cast_Complex is a function that converts an MQC matrix to its 
    complex space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        The MQC matrix to convert.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a261c99eae831fe640b991b32add18035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261c99eae831fe640b991b32add18035">&#9670;&nbsp;</a></span>mqc_matrix_cast_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_cast_integer </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Cast_Integer is a function that converts an MQC matrix to its integer space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Cast_Integer is a function that converts an MQC matrix to its 
    integer space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        The MQC matrix to convert.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="af02da0d912f9a9741edd52654b908b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02da0d912f9a9741edd52654b908b08">&#9670;&nbsp;</a></span>mqc_matrix_cast_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_cast_real </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Cast_Real is a function that converts an MQC matrix to its real space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Cast_Real is a function that converts an MQC matrix to its real 
    space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        The MQC matrix to convert.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a1f5926a9911e81c54d4fd9c1f15dfa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5926a9911e81c54d4fd9c1f15dfa27">&#9670;&nbsp;</a></span>mqc_matrix_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind=int64) function mqc_algebra::mqc_matrix_columns </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Columns is a function used to return the number of columns of an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Columns is a function used to return the number of columns of an MQC 
    matrix. If the matrix is NOT allocated, the number of columns is returned as 0.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a4c797b90ca3c4ad265a9d463a6570345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c797b90ca3c4ad265a9d463a6570345">&#9670;&nbsp;</a></span>mqc_matrix_conjugate_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_conjugate_transpose </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Conjugate_Transpose is a function that returns the conjugate transpose of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Conjugate_Transpose is a function that returns the conjugate 
    transpose of a MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be conjugate transposed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="af67d18eea5dd9bab9ebce77a53c09f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67d18eea5dd9bab9ebce77a53c09f74">&#9670;&nbsp;</a></span>mqc_matrix_copy_complex2int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_copy_complex2int </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Copy_Complex2Int is a subroutine used to copy a complex MQC matrix into its integer space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Copy_Complex2Int is a subroutine used to copy a complex MQC matrix 
    matrix into its integer space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be converted to integer.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aa0132d9cc98355602a93c17beb7858c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0132d9cc98355602a93c17beb7858c5">&#9670;&nbsp;</a></span>mqc_matrix_copy_complex2real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_copy_complex2real </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Copy_Complex2Real is a subroutine used to copy a complex MQC matrix into its real space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Copy_Complex2Real is a subroutine used to copy a complex MQC matrix 
    matrix into its real space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be converted to real.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a625f6cf3e3b057fc28da2edc3b79e2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625f6cf3e3b057fc28da2edc3b79e2fb">&#9670;&nbsp;</a></span>mqc_matrix_copy_int2complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_copy_int2complex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Copy_Int2Complex is a subroutine used to copy an integer MQC matrix into its complex space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Copy_Int2Complex is a subroutine used to copy an integer MQC matrix 
    into its complex space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be converted to complex.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a5e0d58bbdb51cd77e8f62ac4a9afc2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0d58bbdb51cd77e8f62ac4a9afc2ec">&#9670;&nbsp;</a></span>mqc_matrix_copy_int2real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_copy_int2real </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Copy_Int2Real is a subroutine used to copy an integer MQC matrix into its real space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Copy_Int2Real is a subroutine used to copy an integer MQC matrix 
    into its real space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be converted to real.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="aacfde0b3b95688c4788930ee3c1077a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfde0b3b95688c4788930ee3c1077a1">&#9670;&nbsp;</a></span>mqc_matrix_copy_real2complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_copy_real2complex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Copy_Real2Complex is a subroutine used to copy a real MQC matrix into its complex space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Copy_Real2Complex is a subroutine used to copy a real MQC matrix 
    matrix into its complex space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be converted to complex.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ad968ae4927598763a4772bacc5d0ad7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad968ae4927598763a4772bacc5d0ad7f">&#9670;&nbsp;</a></span>mqc_matrix_copy_real2int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_copy_real2int </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Copy_Real2Int is a subroutine used to copy a real MQC matrix into its integer space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Copy_Real2Int is a subroutine used to copy a real MQC matrix matrix 
    into its integer space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be converted to integer.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a66208198c831733979379bd8f085f6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66208198c831733979379bd8f085f6d7">&#9670;&nbsp;</a></span>mqc_matrix_determinant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_matrix_determinant </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Determinant is a function that returns the determinant of an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Determinant is a function that returns the determinant of an MQC 
    matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Matrix)
        The MQC matrix which will be evaluated.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ae17baee9e5f8b7a841edc786ab481a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17baee9e5f8b7a841edc786ab481a7e">&#9670;&nbsp;</a></span>mqc_matrix_diag2full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_diag2full </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Diag2Full is a subroutine that converts a diagonal-packed MQC matrix to unpacked</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Diag2Full is a subroutine that converts a diagonal-packed MQC matrix 
    to unpacked.
      TODO: make tests for diagonal structure more efficient.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be unpacked.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a8a8aee67ccafeb86b35959d1ce1e7da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8aee67ccafeb86b35959d1ce1e7da4">&#9670;&nbsp;</a></span>mqc_matrix_diag2symm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_diag2symm </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Diag2Symm is a subroutine that converts a diagonal-packed MQC matrix to symmetry-packed</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Diag2Symm is a subroutine that converts a diagonal-packed MQC matrix 
    to symmetry-packed.
      TODO: make tests for diagonal structure more efficient.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be unpacked.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a0257675a8f879d16d7d730aabfcb6496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0257675a8f879d16d7d730aabfcb6496">&#9670;&nbsp;</a></span>mqc_matrix_diagmatrix_put_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_diagmatrix_put_complex </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>diagMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_DiagMatrix_Put_Complex is a subroutine that returns a diagonal MQC matrix with elements defined by values in an intrinsic complex vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_DiagMatrix_Put_Complex is a subroutine that returns a diagonal MQC
    matrix with elements defined by values in an intrinsic complex vector.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td><pre class="fragment">        Mat is class(MQC_Matrix)
        MQC matrix to overwrite with output diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DiagMatrixIn</td><td><pre class="fragment">        DiagMatrixIn is complex(kind=real64),dimension(:)
        Intrinsic complex vector to write as diagonal matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a9b4a934665cdcc5c99684b62046cf303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4a934665cdcc5c99684b62046cf303">&#9670;&nbsp;</a></span>mqc_matrix_diagmatrix_put_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_diagmatrix_put_integer </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>diagMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_DiagMatrix_Put_integer is a subroutine that returns a diagonal MQC matrix with elements defined by values in an intrinsic integer vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_DiagMatrix_Put_integer is a subroutine that returns a diagonal MQC
    matrix with elements defined by values in an intrinsic integer vector.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td><pre class="fragment">        Mat is class(MQC_Matrix)
        MQC matrix to overwrite with output diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DiagMatrixIn</td><td><pre class="fragment">        DiagMatrixIn is integer(kind=int64),dimension(:)
        Intrinsic integer vector to write as diagonal matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ac51dfe98702e34c1aea85c65afd8d2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51dfe98702e34c1aea85c65afd8d2be">&#9670;&nbsp;</a></span>mqc_matrix_diagmatrix_put_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_diagmatrix_put_real </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>diagMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_DiagMatrix_Put_Real is a subroutine that returns a diagonal MQC matrix with elements defined by values in an intrinsic real vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_DiagMatrix_Put_Real is a subroutine that returns a diagonal MQC
    matrix with elements defined by values in an intrinsic real vector.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td><pre class="fragment">        Mat is class(MQC_Matrix)
        MQC matrix to overwrite with output diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DiagMatrixIn</td><td><pre class="fragment">        DiagMatrixIn is real(kind=real64),dimension(:)
        Intrinsic real vector to write as diagonal matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a5190dd4e0b311022233f28e391bd51bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5190dd4e0b311022233f28e391bd51bb">&#9670;&nbsp;</a></span>mqc_matrix_diagmatrix_put_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_diagmatrix_put_vector </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>diagVectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_DiagMatrix_Put_Vector is a subroutine that returns a diagonal MQC matrix with elements defined by values in a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_DiagMatrix_Put_Vector is a subroutine that returns a diagonal MQC 
    matrix with elements defined by values in a MQC vector.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DiagVectorIn</td><td><pre class="fragment">        DiagVectorIn is class(MQC_Vector)
        Name of the MQC vector to write as diagonal matrix.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td><pre class="fragment">        Mat is class(MQC_Matrix)
        MQC matrix to overwrite with output diagonal matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2018 </dd></dl>

</div>
</div>
<a id="abf3fb1ad2c32a7547cd2190e94769615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3fb1ad2c32a7547cd2190e94769615">&#9670;&nbsp;</a></span>mqc_matrix_diagonalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_diagonalize </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>EVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>EVecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Diagonalize is a subroutine that takes a symmetric or hermitian MQC matrix and returns eigenvalues and eigenvectors</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Diagonalize is a subroutine that takes a symmetric or hermitian MQC 
    matrix and optionally returns eigenvalues to a MQC vector and/or eigenvectors 
    to a MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Matrix)
        The MQC matrix to diagonalize. </pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EVals</td><td><pre class="fragment">        EVals is Type(MQC_Vector),Optional
        Optional MQC vector containing the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EVecs</td><td><pre class="fragment">        EVecs is Type(MQC_Matrix),Optional
        Optional MQC matrix containing the eigenvectors.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd>
<dd>
L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a92516c8d0a56a9f5b159c5674e5c60f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92516c8d0a56a9f5b159c5674e5c60f1">&#9670;&nbsp;</a></span>mqc_matrix_full2diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_full2diag </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Full2Diag is a subroutine that converts an unpacked MQC matrix to diagonal-packed</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Full2Diag is a subroutine that converts an unpacked MQC matrix to 
    diagonal-packed.
      TODO: make tests for diagonal structure more efficient.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be diagonal packed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="abef463820abe4650a2faeac78e0f4b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef463820abe4650a2faeac78e0f4b4f">&#9670;&nbsp;</a></span>mqc_matrix_full2symm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_full2symm </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Full2Symm is a subroutine that converts an unpacked MQC matrix to symmetric-packed</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Full2Symm is a subroutine that converts an unpacked MQC matrix to 
    symmetric-packed.
      TODO: make tests for symmetry more efficient.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be symmetric packed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a648e057f051a2d1538eccb5ea846c711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648e057f051a2d1538eccb5ea846c711">&#9670;&nbsp;</a></span>mqc_matrix_generalized_eigensystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_generalized_eigensystem </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>bIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(out), optional&#160;</td>
          <td class="paramname"><em>eigenvals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(out), optional&#160;</td>
          <td class="paramname"><em>reigenvecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(out), optional&#160;</td>
          <td class="paramname"><em>leigenvecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Generalized_Eigensystem is a subroutine that takes a MQC matrix and a metric and returns eigenvalues and eigenvectors</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Generalized_Eigensystem is a subroutine that takes a MQC matrix and
    an optional metric (also as an MQC matrix) and optionally returns eigenvalues 
    to a MQC vector and/or left and/or right eigenvectors to an MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Matrix)
        The MQC matrix to diagonalize. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BIn</td><td><pre class="fragment">        BIn is Type(MQC_Matrix),Optional
        The metric. </pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Eigenvals</td><td><pre class="fragment">        Eigenvals is Type(MQC_Vector),Optional
        Optional MQC vector containing the eigenvalues.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">REigenvecs</td><td><pre class="fragment">        REigenvecs is Type(MQC_Matrix),Optional
        Optional MQC matrix containing the right eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LEigenvecs</td><td><pre class="fragment">        LEigenvecs is Type(MQC_Matrix),Optional
        Optional MQC matrix containing the left eigenvectors.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a9b79e988ed88206c28f8d43db5029873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b79e988ed88206c28f8d43db5029873">&#9670;&nbsp;</a></span>mqc_matrix_havecomplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_havecomplex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_HaveComplex is a function used to indicate if an MQC matrix has an allocated complex matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_HaveComplex is a function that returns TRUE if an MQC matrix has an 
    allocated complex matrix and FALSE if it does not.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a3d16caed4314c658cf5d2b7ccb28bbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d16caed4314c658cf5d2b7ccb28bbb8">&#9670;&nbsp;</a></span>mqc_matrix_havediagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_havediagonal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_HaveDiagonal is a function used to indicate if an MQC matrix is stored diagonal-packed</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_HaveDiagonal is a function that returns TRUE if an MQC matrix is stored 
    diagonal-packed and FALSE if it is not.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="af2725ea9543a7f168e193039f993ec53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2725ea9543a7f168e193039f993ec53">&#9670;&nbsp;</a></span>mqc_matrix_havefull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_havefull </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_HaveFull is a function used to indicate if an MQC matrix is stored unpacked</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_HaveFull is a function that returns TRUE if an MQC matrix is stored 
    unpacked and FALSE if it is not.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aa29bf4c1d5435e97d9763a04291c65d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29bf4c1d5435e97d9763a04291c65d0">&#9670;&nbsp;</a></span>mqc_matrix_haveinteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_haveinteger </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_HaveInteger is a function used to indicate if an MQC matrix has an allocated integer matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_HaveInteger is a function that returns TRUE if an MQC matrix has an 
    allocated integer matrix and FALSE if it does not.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="acade87107ad17f989be91301553df8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acade87107ad17f989be91301553df8a6">&#9670;&nbsp;</a></span>mqc_matrix_havereal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_havereal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_HaveReal is a function used to indicate if an MQC matrix has an allocated real matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_HaveReal is a function that returns TRUE if an MQC matrix has an 
    allocated real matrix and FALSE if it does not.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a7c8207ccd518cdc6fb476fb8d178db53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8207ccd518cdc6fb476fb8d178db53">&#9670;&nbsp;</a></span>mqc_matrix_havesymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_havesymmetric </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_HaveSymmetric is a function used to indicate if an MQC matrix is stored symmetric-packed</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_HaveSymmetric is a function that returns TRUE if an MQC matrix is stored 
    symmetric-packed and FALSE if it is not.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="acec9bcc90cf10ad8fe36cecbc373bb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec9bcc90cf10ad8fe36cecbc373bb5c">&#9670;&nbsp;</a></span>mqc_matrix_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_identity </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64)&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Identity is a subroutine that initializes an MQC matrix as an identity matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Identity is a subroutine that initializes an MQC matrix as an  
    identity matrix. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The MQC matrix to initialize as the NxM identity 
        matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">        N is Integer(kind=int64)
        The number of rows to initialize Matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td><pre class="fragment">        M is Integer(kind=int64)
        The number of columns to initialize Matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ad443d560d370221484c3c57a10aac2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad443d560d370221484c3c57a10aac2b4">&#9670;&nbsp;</a></span>mqc_matrix_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_initialize </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>Rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>Columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(*), optional&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>Storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Initialize is a subroutine that initializes an MQC matrix with each element equal to a chosen value</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Initialize is a subroutine that initializes an MQC matrix with each 
    element equal to a chosen value. Optional argument Scalar determines the value
    of each element, with the default equal to zero. Optional argument Storage 
    determines the initial packing of MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The MQC matrix to initialize.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rows</td><td><pre class="fragment">        Rows is Integer(kind=int64)
        The number of rows to initialize Matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Columns</td><td><pre class="fragment">        Columns is Integer(kind=int64)
        The number of columns to initialize Matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(*),Optional
        The value to set each element of Matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Storage</td><td><pre class="fragment">        Storage is Character(Len=*),Optional
        The initial packing of Matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a8794d5bfc83a321363fdef81d521af07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8794d5bfc83a321363fdef81d521af07">&#9670;&nbsp;</a></span>mqc_matrix_inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_inverse </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>)&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Inverse is a function that returns the inverse of an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Inverse is a function that returns the inverse of an MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Matrix)
        The MQC matrix which will be evaluated.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a840d2395f096fc5c91c22b627f610e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840d2395f096fc5c91c22b627f610e2b">&#9670;&nbsp;</a></span>mqc_matrix_isallocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_isallocated </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_isAllocate is a function that returns the allocation status of a MQC_Matrix variable</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_isAllocate is a function that returns the allocation status of a 
    MQC_Matrix variable. The function returns TRUE if the matrix is allocated 
    and FALSE if the matrix is not allocated.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a3609569bc7a7c48d424c657d141cd5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3609569bc7a7c48d424c657d141cd5ef">&#9670;&nbsp;</a></span>mqc_matrix_matrix_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_matrix_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Matrix_At is a function that returns a submatrix of the matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Matrix_At is a function that returns the matrix between rows (I,J) and 
    columns (K,L) of an MQC_Matrix Mat as an MQC_Matrix Matrix. If I, J, K or L is 
    negative, the (N-I+1)th index value is selected.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mat</td><td><pre class="fragment">        Mat is Class(MQC_Matrix)
        Name of the input matrix variable</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td><pre class="fragment">        Rows is Integer(kind=int64),Dimension(:)
        If = [A,B]: output is submatrix of rows A to B
          If (A,B)&gt;0 row count is from first index
          If (A,B)&lt;0 row count is from last index
        If = [0]: submatrix of rows equivalent to [1,-1].</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cols</td><td><pre class="fragment">        Cols is Integer(kind=int64),Dimension(:)
        If = [A,B]: output is submatrix of columns A to B
          If (A,B)&gt;0 column count is from first index
          If (A,B)&lt;0 column count is from last index
        If = [0]: submatrix of columns equivalent to [1,-1].</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="acc8e01e798119d66ffffb76c632be635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8e01e798119d66ffffb76c632be635">&#9670;&nbsp;</a></span>mqc_matrix_matrix_contraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_matrix_matrix_contraction </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Matrix_Contraction is a function that returns the contraction of two MQC matrices</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Matrix_Contraction is a function that returns the contraction of two 
    MQC matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix1</td><td><pre class="fragment">        Matrix1 is Type(MQC_Matrix)
        The first MQC matrix to contract.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix2</td><td><pre class="fragment">        Matrix2 is Type(MQC_Matrix)
        The second MQC matrix to contract.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a228aa4094ce52274a2a6e3d2b40c78a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228aa4094ce52274a2a6e3d2b40c78a3">&#9670;&nbsp;</a></span>mqc_matrix_matrix_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">recursive subroutine mqc_algebra::mqc_matrix_matrix_put </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MatrixIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Matrix_Put is a subroutine that writes a submatrix to the specified position of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Matrix_Put is a subroutine that writes a submatrix to the specified
    position of a MQC matrix. The row and column specification are given as a vector 
    where each vector must contain either zero or two non-zero integers to specify 
    the range of elements that will be overwritten by the submatrix. If the value 
    of an element specification is negative, it counts from the last element back. 
    If the value of an element specification is zero, the whole row/column is 
    specified.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Mat</td><td><pre class="fragment">        Mat is Class(MQC_Matrix)
        The MQC matrix from which to return the subvector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MatrixIn</td><td><pre class="fragment">        MatrixIn is Type(MQC_Matrix)
        The submatrix to overwrite at the specified elements 
        of Mat.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rows</td><td><pre class="fragment">        Rows is Integer(kind=int64),Dimension(:)
        The specification of the rows to include in the 
        subvector. 
        If = [A,B]: output is subvector of rows A to B
          If (A,B)&gt;0 row count is from first index
          If (A,B)&lt;0 row count is from last index
        If = [0]: subvector of rows equivalent to [1,-1].</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cols</td><td><br  />
 <pre class="fragment">        Cols is Integer(kind=int64),Dimension(:)
        The specification of the columns to include in the 
        subvector. 
        If = [A,B]: output is subvector of columns A to B
          If (A,B)&gt;0 column count is from first index
          If (A,B)&lt;0 column count is from last index
        If = [0]: subvector of columns equivalent to [1,-1].</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a55dde5f99073fe3cf79e23acca3e987d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dde5f99073fe3cf79e23acca3e987d">&#9670;&nbsp;</a></span>mqc_matrix_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_matrix_norm </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=1), intent(in), optional&#160;</td>
          <td class="paramname"><em>methodIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Norm is a function that returns the norm of an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Norm is a function that returns the norm of an MQC matrix. The 
    following options are available:

    1. methodIn = 'M' uses the maximum absolute value max(abs(A(i,j))).
    2. methodIn = '1' uses the one norm.
    3. methodIn = 'I' uses the infinity norm.
    4. methodIn = 'F' uses the Frobenius norm (default).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The name of the MQC_Matrix variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MethodIn</td><td><pre class="fragment">        MethodIn is Character(len=1)
        = 'M': max(abs(A(i,j)))
        = '1': one norm
        = 'I': infinity norm
        = 'F': Frobenius norm.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ad9d3af3c878fdc1247f135ee8bf7cae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d3af3c878fdc1247f135ee8bf7cae9">&#9670;&nbsp;</a></span>mqc_matrix_rms_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_rms_max </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(out)&#160;</td>
          <td class="paramname"><em>rms_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(out)&#160;</td>
          <td class="paramname"><em>max_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_RMS_Max is a subroutine that returns the RMS and maximum values of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_RMS_Max is a subroutine that returns the RMS and maximum values of a 
    MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Matrix)
        The MQC matrix to evaluate.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RMS_A</td><td><pre class="fragment">        RMS_A is Type(MQC_Scalar)
        Returns the RMS value of matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Max_A</td><td><pre class="fragment">        Max_A is Type(MQC_Scalar)
        Returns the maximum value of matrix A.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a51ba8f0a20ce59677fd7cad2a9e24bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ba8f0a20ce59677fd7cad2a9e24bf7">&#9670;&nbsp;</a></span>mqc_matrix_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind=int64) function mqc_algebra::mqc_matrix_rows </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Rows is a function used to return the number of rows of an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Rows is a function used to return the number of rows of an MQC 
    matrix. If the matrix is NOT allocated, the number of rows is returned as 0.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a6da4e494a21e7ea9e1fbd2198278e0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da4e494a21e7ea9e1fbd2198278e0ce">&#9670;&nbsp;</a></span>mqc_matrix_scalar_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_matrix_scalar_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Scalar_At is a function that returns the value of an <br  />
 element of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Scalar_At is a function that returns the value of (I,J)th element of 
    a MQC matrix as an MQC scalar. If I or J is negative, the (N-I+1)th index is 
    selected.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mat</td><td><pre class="fragment">        Mat is Class(MQC_Matrix)
        The MQC matrix to return the value of the (I,J)th 
        element.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><br  />
 <pre class="fragment">        I is Integer(kind=int64)
        The row of the element in MQC matrix. 
          If I&gt;0 row count is from first index
          If I&lt;0 row count is from last index.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td><br  />
 <pre class="fragment">        J is Integer(kind=int64)
        The column of the element in MQC matrix.
          If J&gt;0 row count is from first index
          If J&lt;0 row count is from last index.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd>
<dd>
L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a7a0a2b8295316e1ff182faea150106fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0a2b8295316e1ff182faea150106fc">&#9670;&nbsp;</a></span>mqc_matrix_scalar_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_scalar_put </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Scalar_Put is a subroutine that updates the value of the (i,j)th element of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Scalar_Put is a subroutine that updates the value of the (i,j)th 
    element of a MQC matrix. If the location of an element is negative then it is 
    counted from the end of the MQC matrix row/column.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to update at the (i,j)th element..</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The value to update the (i,j)th element of Matrix..</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">        I is Integer(kind=int64) 
        The location of the row element in Matrix to update. If 
        I is negative it is counted from the last element of 
        Matrix</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td><pre class="fragment">        J is Integer(kind=int64) 
        The location of the column element in Matrix to update. 
        If J is negative it is counted from the last element of 
        Matrix</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a8f816bab517aac5d63f5d9b8ed02dd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f816bab517aac5d63f5d9b8ed02dd18">&#9670;&nbsp;</a></span>mqc_matrix_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_set </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(*), optional&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Set is a subroutine that sets an MQC matrix to a value without resizing its dimensions</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Set is a subroutine that sets an MQC matrix to a value without
    resizing its dimensions. Optional argument scalar specifies the value to set
    each element of the matrix, where the default value is 0.0. Optional argument
    storage allows the storage of the matrix to be defined, where the default is
    unpacked. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The MQC matrix to set values of elements.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(*),Optional
        The value to set each element of Matrix. The default
        is 0.0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Storage</td><td><pre class="fragment">        Storage is Character(len=*),Optional
        The packing of the Matrix. The default is unpacked.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ae20713aedbc2621c6649a8ab0d26c411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20713aedbc2621c6649a8ab0d26c411">&#9670;&nbsp;</a></span>mqc_matrix_sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_sqrt </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>eVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>eVecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Sqrt is a subroutine that returns the square root of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Sqrt is a subroutine that returns the square root of a MQC matrix.
    Note that the matrix has to be symmetric or hermitian. Optionally, eigenvalues 
    and/or eigenvectors are returned.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Matrix)
        The MQC matrix to evaluate.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EVals</td><td><pre class="fragment">        EVals is Type(MQC_Vector),Optional
        The eigenvalues of matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EVecs</td><td><pre class="fragment">        EVecs is Type(MQC_Matrix)
        The eigenvectors of matrix A.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a6bf0a09beb557ab60485c31b884790ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf0a09beb557ab60485c31b884790ff">&#9670;&nbsp;</a></span>mqc_matrix_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_svd </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>EVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>EUVecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout), optional&#160;</td>
          <td class="paramname"><em>EVVecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_SVD is a subroutine that computes the singular value decomposition of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_SVD is a subroutine that computes the singular value decomposition 
    of a MQC matrix.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Matrix)
        The MQC matrix to decompose.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EVals</td><td><pre class="fragment">        Eigenvals is Type(MQC_Vector),Optional
        Optional MQC vector containing the singular values.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EUVecs</td><td><pre class="fragment">        EUVecs is Type(MQC_Matrix),Optional
        Optional MQC matrix containing the U vectors.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EVVecs</td><td><pre class="fragment">        EVVecs is Type(MQC_Matrix),Optional
        Optional MQC matrix containing the V vectors.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="adb8fe92d1f31abbeb4c23127776581c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8fe92d1f31abbeb4c23127776581c3">&#9670;&nbsp;</a></span>mqc_matrix_symm2diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_symm2diag </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Symm2Diag is a subroutine that converts a symmetry-packed MQC matrix to diagonal-packed</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Symm2Diag is a subroutine that converts a symmetry-packed MQC matrix to 
    diagonal-packed.
      TODO: make tests for diagonal structure more efficient.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be diagonal packed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a3b5ef28f290e4f9f1ce51fe154d91533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5ef28f290e4f9f1ce51fe154d91533">&#9670;&nbsp;</a></span>mqc_matrix_symm2full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_symm2full </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>Option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Symm2Full is a subroutine that converts a symmetry-packed MQC matrix to unpacked</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Symm2Full is a subroutine that converts a symmetry-packed MQC matrix 
    to unpacked. The following options are available:
      Option = 'symmetric' unpacks as if matrix is symmetric.
      Option = 'antisymmetric' unpacks as if matrix is antisymmetric.
      Option = 'hermitian' unpacks as if matrix is hermitian.
      Option = 'antihermitian' unpacks as if matrix is antihermitian.

      TODO: when different symm storage flags implemented, use these rather than an
            option</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to unpack.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Option</td><td><pre class="fragment">        Option is Character(len=*),Optional
        = 'symmetric':      Unpack as if matrix is symmetric
        = 'antisymmetric':  Unpack as if matrix is antisymmetric
        = 'hermitian':      Unpack as if matrix is hermitian
        = 'antihermitian':  Unpack as if matrix is antihermitian</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016, 2018 </dd></dl>

</div>
</div>
<a id="adf3898fe4dcc387ce87913df99da20cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3898fe4dcc387ce87913df99da20cb">&#9670;&nbsp;</a></span>mqc_matrix_symm2full_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_symm2full_func </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Symm2Full_Func is a function that converts a symmetric- packed MQC matrix to unpacked</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Symm2Full_Func is a function that converts a symmetric-packed MQC matrix 
    to unpacked.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be unpacked.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ac797640c3e0bb06f8fdf7be857845957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac797640c3e0bb06f8fdf7be857845957">&#9670;&nbsp;</a></span>mqc_matrix_symmetrize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_symmetrize </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Symmetrize is a function that symmetrizes a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Symmetrize is a function that symmetrizes a MQC matrix. 
      TODO: options to antisymmetrize, hermitianize and antihermitianize. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be symmetrized.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a540647c8ae1cb6741daad88911807139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540647c8ae1cb6741daad88911807139">&#9670;&nbsp;</a></span>mqc_matrix_symmmatrix_put_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_symmmatrix_put_complex </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>symmMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_SymmMatrix_Put_Complex is a subroutine that returns a symmetric packed MQC matrix with elements defined by values in an intrinsic complex vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_SymmMatrix_Put_Complex is a subroutine that returns a symmetric 
    packed MQC matrix with elements defined by values in an intrinsic complex
    vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td><pre class="fragment">        Mat is class(MQC_Matrix)
        MQC matrix to overwrite with output symmetric matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SymmMatrixIn</td><td><pre class="fragment">        SymmMatrixIn is complex(kind=real64),dimension(:)
        Intrinsic complex vector to write as symmetric-packed 
        matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a874218f3a41af94853ebfed27a74f27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874218f3a41af94853ebfed27a74f27f">&#9670;&nbsp;</a></span>mqc_matrix_symmmatrix_put_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_symmmatrix_put_integer </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>symmMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_SymmMatrix_Put_Integer is a subroutine that returns a symmetric packed MQC matrix with elements defined by values in an intrinsic integer vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_SymmMatrix_Put_Integer is a subroutine that returns a symmetric 
    packed MQC matrix with elements defined by values in an intrinsic integer 
    vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td><pre class="fragment">        Mat is class(MQC_Matrix)
        MQC matrix to overwrite with output symmetric matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SymmMatrixIn</td><td><pre class="fragment">        SymmMatrixIn is integer(kind=int64),dimension(:)
        Intrinsic integer vector to write as symmetric-packed 
        matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a7d04d32e23c58f1a14085b5f3fa9e9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d04d32e23c58f1a14085b5f3fa9e9f5">&#9670;&nbsp;</a></span>mqc_matrix_symmmatrix_put_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_symmmatrix_put_real </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>symmMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_SymmMatrix_Put_Real is a subroutine that returns a symmetric packed MQC matrix with elements defined by values in an intrinsic real vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_SymmMatrix_Put_Real is a subroutine that returns a symmetric 
    packed MQC matrix with elements defined by values in an intrinsic real
    vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mat</td><td><pre class="fragment">        Mat is class(MQC_Matrix)
        MQC matrix to overwrite with output symmetric matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SymmMatrixIn</td><td><pre class="fragment">        SymmMatrixIn is real(kind=real64),dimension(:)
        Intrinsic real vector to write as symmetric-packed 
        matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ae168e90d957c7858f3e46cee806587c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae168e90d957c7858f3e46cee806587c3">&#9670;&nbsp;</a></span>mqc_matrix_symmsymmr4tensor_put_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_symmsymmr4tensor_put_complex </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>r4Tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>symmSymmMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12d068f8df321ac955582abba9f6a684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d068f8df321ac955582abba9f6a684">&#9670;&nbsp;</a></span>mqc_matrix_symmsymmr4tensor_put_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_matrix_symmsymmr4tensor_put_real </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>r4Tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>symmSymmMatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ad61cf37cde19aa4f02ffaf341995d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad61cf37cde19aa4f02ffaf341995d0">&#9670;&nbsp;</a></span>mqc_matrix_test_diagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_test_diagonal </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Test_Diagonal is a function that tests a MQC matrix to determine if it is diagonal</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Test_Diagonal is a function that tests a MQC matrix to determine 
    if it is diagonal. The function returns TRUE if the matrix is diagonal and 
    FALSE if the matrix is not diagonal.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(mqc_matrix)
        The matrix to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aefa84c562aa9933eead2de01256e418d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa84c562aa9933eead2de01256e418d">&#9670;&nbsp;</a></span>mqc_matrix_test_symmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_matrix_test_symmetric </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>Option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Test_Symmetric is a function that tests a MQC matrix for symmetry</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Test_Symmetric is a function that tests a MQC matrix for symmetry 
    specified by optional argument, with the default test being for a symmetric
    matrix. Note that this function differs from haveSymmetric subroutine which
    tests how a matrix is packed. The following options are available: 

    1. Option = 'symmetric' tests for a symmetric matrix (default).
    2. Option = 'antisymmetric' tests for an antisymmetric matrix.
    3. Option = 'hermitian' tests for a hermitian matrix.
    4. Option = 'antihermitian' tests for an antihermitian matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(mqc_matrix)
        The matrix to be tested for symmetry.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Option</td><td><pre class="fragment">        Option is Character(len=*),Optional
        = 'symmetric':     symmetric matrix test
        = 'antisymmetric': antisymmetric matrix test
        = 'hermitian':     hermitian matrix test
        = 'antihermitian': antihermitian matrix test.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ab79ede23293575f7658fd5fa6cdd47e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79ede23293575f7658fd5fa6cdd47e9">&#9670;&nbsp;</a></span>mqc_matrix_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_matrix_trace </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Trace is a function that returns the trace of an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Trace is a function that returns the trace of an MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The MQC matrix which will be evaluated.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a60dc9a6d8c03968a055211b3d9b1f105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dc9a6d8c03968a055211b3d9b1f105">&#9670;&nbsp;</a></span>mqc_matrix_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrix_transpose </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Transpose is a function that returns the transpose of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Transpose is a function that returns the transpose of a MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to be transposed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd>
<dd>
X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016, 2017 </dd></dl>

</div>
</div>
<a id="a6928e084da14a1fb181ab7e264fda37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6928e084da14a1fb181ab7e264fda37c">&#9670;&nbsp;</a></span>mqc_matrix_vector_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_matrix_vector_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Vector_At is a function that returns the subvector of an <br  />
 MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Vector_At is a function that returns the subvector of an MQC matrix.
    The row and column specification are given as a vector where one vector must 
    contain a single non-zero integer to specify the row or column of the 
    subvector, and the other vector must be either zero or two non-zero integers to
    specify the range of elements that will form the subvector. If the value of an
    element specification is negative, it counts from the last element back. If the
    value of an element specification is zero, the whole row/column is specified.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mat</td><td><pre class="fragment">        Mat is Class(MQC_Matrix)
        The MQC matrix from which to return the subvector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rows</td><td><pre class="fragment">        Rows is Integer(kind=int64),Dimension(:)
        The specification of the rows to include in the 
        subvector. 
        If = [A,B]: output is subvector of rows A to B
          If (A,B)&gt;0 row count is from first index
          If (A,B)&lt;0 row count is from last index
        If = [0]: subvector of rows equivalent to [1,-1].</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cols</td><td><br  />
 <pre class="fragment">        Cols is Integer(kind=int64),Dimension(:)
        The specification of the columns to include in the 
        subvector. 
        If = [A,B]: output is subvector of columns A to B
          If (A,B)&gt;0 column count is from first index
          If (A,B)&lt;0 column count is from last index
        If = [0]: subvector of columns equivalent to [1,-1].</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ac72ca45faf635b0f22318fdc8ac957b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72ca45faf635b0f22318fdc8ac957b9">&#9670;&nbsp;</a></span>mqc_matrix_vector_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">recursive subroutine mqc_algebra::mqc_matrix_vector_put </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>Cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Matrix_Vector_Put is a subroutine that writes a subvector to the specified position of a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Matrix_Vector_Put is a subroutine that writes a subvector to the specified
    position of a MQC matrix. The row and column specification are given as a vector 
    where one vector must contain a single non-zero integer to specify the row or 
    column where the subvector will be written, and the other vector must be either 
    zero or two non-zero integers to specify the range of elements that will be
    overwritten by the subvector. If the value of an element specification is 
    negative, it counts from the last element back. If the value of an element 
    specification is zero, the whole row/column is specified.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Mat</td><td><pre class="fragment">        Mat is Class(MQC_Matrix)
        The MQC matrix from which to return the subvector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Type(MQC_Vector)
        The subvector to overwrite at the specified elements 
        of Mat.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Rows</td><td><pre class="fragment">        Rows is Integer(kind=int64),Dimension(:)
        The specification of the rows to include in the 
        subvector. 
        If = [A,B]: output is subvector of rows A to B
          If (A,B)&gt;0 row count is from first index
          If (A,B)&lt;0 row count is from last index
        If = [0]: subvector of rows equivalent to [1,-1].</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cols</td><td><br  />
 <pre class="fragment">        Cols is Integer(kind=int64),Dimension(:)
        The specification of the columns to include in the 
        subvector. 
        If = [A,B]: output is subvector of columns A to B
          If (A,B)&gt;0 column count is from first index
          If (A,B)&lt;0 column count is from last index
        If = [0]: subvector of columns equivalent to [1,-1].</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ab3603ce30c98db8c2332c2a41803d9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3603ce30c98db8c2332c2a41803d9e9">&#9670;&nbsp;</a></span>mqc_matrixmatrixdotproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrixmatrixdotproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_MatrixMatrixDotProduct is a function that computes the inner product of two MQC matrices</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_MatrixMatrixDotProduct is a function that computes the inner product of 
    two MQC matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        The first MQC matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MB</td><td><pre class="fragment">        MB is Type(MQC_Matrix)
        The second MQC matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a447b09386b734386f15489c647a89a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447b09386b734386f15489c647a89a1b">&#9670;&nbsp;</a></span>mqc_matrixmatrixproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrixmatrixproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_MatrixMatrixProduct is a function that computes the element- wise product of two MQC matrices</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_MatrixMatrixProduct is a function that computes the element-wise product of 
    two MQC matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        The first MQC matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MB</td><td><pre class="fragment">        MB is Type(MQC_Matrix)
        The second MQC matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a645e3425761f5a431b864ba730d7a2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645e3425761f5a431b864ba730d7a2a7">&#9670;&nbsp;</a></span>mqc_matrixmatrixsubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrixmatrixsubtract </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_MatrixMatrixSubtract is a function that subtracts two MQC matrices</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_MatrixMatrixSubtract is a function that subtracts two MQC matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        The matrix that MB will be subtracted from.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MB</td><td><pre class="fragment">        MB is Type(MQC_Matrix)
        The matrix that will be subtracted from MA.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a80828c415886bec8f4bda38064f7366c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80828c415886bec8f4bda38064f7366c">&#9670;&nbsp;</a></span>mqc_matrixmatrixsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrixmatrixsum </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_MatrixMatrixSum is a function that sums two MQC matrices</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_MatrixMatrixSum is a function that sums two MQC matrices.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        First MQC matrix to sum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MB</td><td><pre class="fragment">        MB is Type(MQC_Matrix)
        Second MQC matrix to sum.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd>
<dd>
L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017, 2018 </dd></dl>

</div>
</div>
<a id="aedf13b444bd513d0fec9ec1842dd11ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf13b444bd513d0fec9ec1842dd11ca">&#9670;&nbsp;</a></span>mqc_matrixscalarproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_matrixscalarproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_MatrixScalarProduct is a function that computes the product of a MQC scalar and a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_MatrixScalarProduct is a function that computes the inner product of a MQC 
    scalar and a MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC scalar to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a8bf0f266a7c3eff1a58e31758e1da31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf0f266a7c3eff1a58e31758e1da31d">&#9670;&nbsp;</a></span>mqc_matrixvectordotproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_matrixvectordotproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_MatrixVectorDotProduct is a function that computes the inner product of a MQC matrix and a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_MatrixVectorDotProduct is a function that computes the inner product of 
    a MQC matrix and a MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">MA</td><td><pre class="fragment">        MA is Type(MQC_Matrix)
        The MQC matrix multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td><pre class="fragment">        VB is Type(MQC_Vector)
        The MQC vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ae62c5033c0d7cbc2cf794d2215f15873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62c5033c0d7cbc2cf794d2215f15873">&#9670;&nbsp;</a></span>mqc_outer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_outer </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Outer is a function that returns the outer product of two MQC vectors</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Outer is a function that returns the outer product of two MQC vectors. The
    first vector should be a column vector, while the second vector should be a row 
    vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td><pre class="fragment">        VA is Type(MQC_Vector)
        The MQC column vector. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td><pre class="fragment">        VB is Type(MQC_Vector)
        The MQC row vector. </pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a96121d1d330a9dff5a51182cd598f6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96121d1d330a9dff5a51182cd598f6fd">&#9670;&nbsp;</a></span>mqc_output_complex_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_output_complex_scalar </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), intent(inout)&#160;</td>
          <td class="paramname"><em>ScalarOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Output_Complex_Scalar is a subroutine used to output an intrinsic complex equal to an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Output_Complex_Scalar is a subroutine used to output an intrinsic complex equal to an MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScalarOut</td><td><pre class="fragment">        ScalarOut is Complex(kind=real64) 
        The name of the output variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar) 
        The value of the input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a1b4787b08e3af49020e71cc1e07e79c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4787b08e3af49020e71cc1e07e79c2">&#9670;&nbsp;</a></span>mqc_output_integer_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_output_integer_scalar </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(inout)&#160;</td>
          <td class="paramname"><em>ScalarOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Output_Integer_Scalar is a subroutine used to output an intrinsic integer equal to an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Output_Integer_Scalar is a subroutine used to output an intrinsic integer equal to an MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScalarOut</td><td><pre class="fragment">        ScalarOut is Integer(kind=int64) 
        The name of the output variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar) 
        The value of the input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="abaea000448e874bbf904b19d76dcdd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaea000448e874bbf904b19d76dcdd1e">&#9670;&nbsp;</a></span>mqc_output_mqcscalar_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_output_mqcscalar_scalar </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>ScalarOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Output MQCScalar_Scalar is a subroutine used to output an MQC_scalar equal to an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Output_MQCScalar_Scalar is a subroutine used to output an MQC_scalar equal to an MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScalarOut</td><td><pre class="fragment">        ScalarOut is Type(MQC_Scalar)
        The name of the output variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar) 
        The value of the input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ae7a5d645191f50e053bf5c79f2d8b14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a5d645191f50e053bf5c79f2d8b14c">&#9670;&nbsp;</a></span>mqc_output_real_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_output_real_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(inout)&#160;</td>
          <td class="paramname"><em>ScalarOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Output_Real_Scalar is a subroutine used to output an intrinsic real equal to an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Output_Complex_Scalar is a subroutine used to output an intrinsic real equal to an MQC_Scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ScalarOut</td><td><pre class="fragment">        ScalarOut is Real(kind=real64) 
        The name of the output variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar) 
        The value of the input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a18f6e2214dff5439ec0aa9d6202a40ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f6e2214dff5439ec0aa9d6202a40ab">&#9670;&nbsp;</a></span>mqc_print_matrix_algebra1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_print_matrix_algebra1 </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>Blank_At_Top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>Blank_At_Bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Print_Matrix_Algebra1 is a subroutine used to print an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Print_Matrix_Algebra1 is a subroutine used to print an MQC matrix. 
    Blank_At_Top and Blank_At_Bottom are optional logical arguments to print blank
    lines before or after output.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Class(MQC_Matrix)
        The variable to be printed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IOut</td><td><pre class="fragment">        IOut is Integer(kind=int64) 
        The Fortran file number to print to. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Header</td><td><pre class="fragment">        Header is Character(Len=*)
        The title to print along with Matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blank_At_Top</td><td><pre class="fragment">        Blank_At_Top is Logical,Optional
        = .True.:  print blank line above output
        = .False.: do not print blank line above output.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blank_At_Bottom</td><td><pre class="fragment">        Blank_At_Bottom is Logical,Optional
        = .True.:  print blank line below output
        = .False.: do not print blank line below output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="abf5aa22c14da0bd4a866e2370b36d9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5aa22c14da0bd4a866e2370b36d9fc">&#9670;&nbsp;</a></span>mqc_print_r4tensor_algebra1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_print_r4tensor_algebra1 </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, optional&#160;</td>
          <td class="paramname"><em>blank_at_top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, optional&#160;</td>
          <td class="paramname"><em>blank_at_bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5670e978555bc722597a13578193113d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5670e978555bc722597a13578193113d">&#9670;&nbsp;</a></span>mqc_print_scalar_algebra1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_print_scalar_algebra1 </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>Blank_At_Top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>Blank_At_Bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Print_Scalar_Algebra1 is a subroutine used to print an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Print_Scalar_Algebra1 is a subroutine used to print an MQC_Scalar. Blank_At_Top
    and Blank_At_Bottom are optional logical arguments to print blank lines before or
    after output.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(MQC_Scalar)
        The variable to be printed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IOut</td><td><pre class="fragment">        IOut is Integer(kind=int64) 
        The Fortran file number to print to. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Header</td><td><pre class="fragment">        Header is Character(Len=*)
        The title to print along with Scalar.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blank_At_Top</td><td><pre class="fragment">        Blank_At_Top is Logical,Optional
        = .True.:  print blank line above output
        = .False.: do not print blank line above output.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blank_At_Bottom</td><td><pre class="fragment">        Blank_At_Bottom is Logical,Optional
        = .True.:  print blank line below output
        = .False.: do not print blank line below output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ae64f8cd347b0d00129d7fce3ea323c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64f8cd347b0d00129d7fce3ea323c46">&#9670;&nbsp;</a></span>mqc_print_vector_algebra1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_print_vector_algebra1 </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>Verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>Blank_At_Top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>Blank_At_Bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Print_Vector_Algebra1 is a subroutine used to print an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Print_Vector_Algebra1 is a subroutine used to print an MQC vector. 
    Blank_At_Top and Blank_At_Bottom are optional logical arguments to print blank
    lines before or after output.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The variable to be printed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IOut</td><td><pre class="fragment">        IOut is Integer(kind=int64) 
        The Fortran file number to print to. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Header</td><td><pre class="fragment">        Header is Character(Len=*)
        The title to print along with Vector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Verbose</td><td><pre class="fragment">        Verbose is Logical,Optional
        Adds extra printing to output.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blank_At_Top</td><td><pre class="fragment">        Blank_At_Top is Logical,Optional
        = .True.:  print blank line above output
        = .False.: do not print blank line above output.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Blank_At_Bottom</td><td><pre class="fragment">        Blank_At_Bottom is Logical,Optional
        = .True.:  print blank line below output
        = .False.: do not print blank line below output.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a6e8dd8de2a67def6b122ae5cd47a7c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8dd8de2a67def6b122ae5cd47a7c62">&#9670;&nbsp;</a></span>mqc_r4tensor_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_r4tensor_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac546a96a95d1f312446237d53d3c0b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac546a96a95d1f312446237d53d3c0b1c">&#9670;&nbsp;</a></span>mqc_r4tensor_havecomplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_r4tensor_havecomplex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(in)&#160;</td>
          <td class="paramname"><em>R4Tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a148537e9a896894b25e159753c262704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148537e9a896894b25e159753c262704">&#9670;&nbsp;</a></span>mqc_r4tensor_haveinteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_r4tensor_haveinteger </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(in)&#160;</td>
          <td class="paramname"><em>R4Tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae34f03e88192b3cf9f2a561bdf8b479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f03e88192b3cf9f2a561bdf8b479c">&#9670;&nbsp;</a></span>mqc_r4tensor_havereal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_r4tensor_havereal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(in)&#160;</td>
          <td class="paramname"><em>R4Tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f5d378d98af2e37361a7c88d69ea155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5d378d98af2e37361a7c88d69ea155">&#9670;&nbsp;</a></span>mqc_r4tensor_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_r4tensor_initialize </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>R4Tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(*), optional&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab74124faccbf37cc34cd219065c146b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74124faccbf37cc34cd219065c146b1">&#9670;&nbsp;</a></span>mqc_r4tensor_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_r4tensor_put </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a411d628bc48e836f1e9446f6400a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a411d628bc48e836f1e9446f6400a88">&#9670;&nbsp;</a></span>mqc_realgtscalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_realgtscalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealGTScalar is a function that returns TRUE if an intrinsic real is greater than a MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealGTScalar is a function that returns TRUE if an intrinsic real is greater 
    than a MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the intrinsic real
    is greater than the real part of the MQC_Scalar and FALSE if the intrinsic real is 
    less than the real part of the MQC_Scalar. If the intrinsic real is equal to the
    real part of the MQC_Scalar, the function returns TRUE if the imaginary part of 
    MQC_Scalar is less than zero and FALSE otherwise.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="afb3c883ffc8067c04af4c5c9a2351cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3c883ffc8067c04af4c5c9a2351cbc">&#9670;&nbsp;</a></span>mqc_reallescalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_reallescalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealLEScalar is a function that returns TRUE if an intrinsic real is less than or equal to a MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealLEScalar is a function that returns TRUE if an intrinsic real is less than or  
    equal to a MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the intrinsic real
    is less than or equal to the real part of the MQC_Scalar and FALSE if the intrinsic 
    real is greater than the real part of the MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ab92daddcf574bca2e97a35d004ecbf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92daddcf574bca2e97a35d004ecbf90">&#9670;&nbsp;</a></span>mqc_realltscalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_realltscalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealLTScalar is a function that returns TRUE if an intrinsic real is less than a MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealLTScalar is a function that returns TRUE if an intrinsic real is less than
    a MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the intrinsic real 
    is less than the real part of the MQC_Scalar and FALSE if the intrinsic real is 
    greater than the real part of the MQC_Scalar. If the intrinsic real is equal to the
    real part of the MQC_Scalar, the function returns TRUE if the imaginary part of 
    MQC_Scalar is greater than zero and FALSE otherwise.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ad48627500935e05d982407ab0adbe144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48627500935e05d982407ab0adbe144">&#9670;&nbsp;</a></span>mqc_realscalaradd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_realscalaradd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealScalarAdd is a function that is used to sum an intrinsic real by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealScalarAdd is a function that is used to sum an intrinsic real by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">realIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real variable to sum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to sum.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="aa52a7f2f065dde607c59f11a33fa6b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52a7f2f065dde607c59f11a33fa6b68">&#9670;&nbsp;</a></span>mqc_realscalardivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_realscalardivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealScalarDivide is a function that is used to divide an intrinsic real by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealScalarDivide is a function that is used to divide an intrinsic real by an
    MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real variable numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a06c0fa9503e54a88841d9f5b3afc7a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c0fa9503e54a88841d9f5b3afc7a21">&#9670;&nbsp;</a></span>mqc_realscalarmultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_realscalarmultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealScalarMultiply is a function that is used to multiply an intrinsic real by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealScalarMultiply is a function that is used to multiply an intrinsic real by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">realIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real variable to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a8ea3e486f62a29ff78bc55bc78898d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea3e486f62a29ff78bc55bc78898d4b">&#9670;&nbsp;</a></span>mqc_realscalarsubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_realscalarsubtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealScalarSubtract is a function that is used to subtract an MQC_Scalar from an intrinisic real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealScalarSubtract is a function that is used to subtract an MQC_Scalar from an
    intrinisic real. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real to subtract from.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to subtract.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a7b7d6963c3e803f0a8a1487062c5551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7d6963c3e803f0a8a1487062c5551b">&#9670;&nbsp;</a></span>mqc_realvectorproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_realvectorproduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_RealVectorProduct is a function that returns the product of an <br  />
 intrinsic real scalar and a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_RealVectorProduct is a function that returns the product of an intrinsic 
    real scalar and a MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The real intrinsic to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a95af3b088b74de094de82c7cb295fd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95af3b088b74de094de82c7cb295fd52">&#9670;&nbsp;</a></span>mqc_scalar_acos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_acos </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_ACos is a function used to return the arccosine of an MQC_scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_ACos is a function used to return the arccosine of an MQC_scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a1798346798e9e802b6387fe247f20b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1798346798e9e802b6387fe247f20b71">&#9670;&nbsp;</a></span>mqc_scalar_asin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_asin </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_ASin is a function used to return the arcsin of an MQC_scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_ASin is a function used to return the arcsin of an MQC_scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a6aedd6ad2e5ae41c15bf5189872fa807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aedd6ad2e5ae41c15bf5189872fa807">&#9670;&nbsp;</a></span>mqc_scalar_atan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_atan </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_ATan is a function used to return the arctangent of an MQC_scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_ATan is a function used to return the arctangent of an MQC_scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a5ef50435730a6d10b5d32b4a991a8321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef50435730a6d10b5d32b4a991a8321">&#9670;&nbsp;</a></span>mqc_scalar_atan2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_atan2 </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_ATan2 is a function used to return the arctangent of an MQC_scalar accounting for quadrant of Argand diagram</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_ATan2 is a function used to return the arctangent of an MQC_scalar
    accounting for quadrant of Argand diagram.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a5c3f4c6cbf89a7d3091e7a05a70def10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3f4c6cbf89a7d3091e7a05a70def10">&#9670;&nbsp;</a></span>mqc_scalar_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_cmplx </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Cmplx is a function used to set a complex MQC_Scalar type variable from two other MQC_scalars</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Cmplx is a function used to set a complex MQC_Scalar type variable 
    from two other MQC_Scalar variables.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The real part of MQC_Scalar_Cmplx.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The imaginary part of MQC_Scalar_Cmplx.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="aa021bafadf4e7694dfc4aa647b9e6743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa021bafadf4e7694dfc4aa647b9e6743">&#9670;&nbsp;</a></span>mqc_scalar_complex_conjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_complex_conjugate </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Complex_Conjugate is a function that returns the complex conjugate of an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Complex_Conjugate is a function that returns the complex conjugate of an 
    MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar)
        The MQC_Scalar input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2018 </dd></dl>

</div>
</div>
<a id="a486846cf71687686d5d1cd5a91f4959b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486846cf71687686d5d1cd5a91f4959b">&#9670;&nbsp;</a></span>mqc_scalar_complex_imagpart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_complex_imagpart </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Complex_ImagPart is a function that returns the inaginary part of an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Complex_RealPart is a function that returns the imaginary part of an
    MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar)
        The MQC_Scalar input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a064e55d8a10812f4423d4c7c85db064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064e55d8a10812f4423d4c7c85db064c">&#9670;&nbsp;</a></span>mqc_scalar_complex_realpart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_complex_realpart </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Complex_RealPart is a function that returns the real part of an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Complex_RealPart is a function that returns the real part of an
    MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar)
        The MQC_Scalar input variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ac82434bee8bd4e7535e23968f39c004c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82434bee8bd4e7535e23968f39c004c">&#9670;&nbsp;</a></span>mqc_scalar_cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_cos </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Cos is a function used to return the cosine of an MQC_scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Cos is a function used to return the cosine of an MQC_scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a3dde75fe02e3744f5f6da074ac4c0f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dde75fe02e3744f5f6da074ac4c0f39">&#9670;&nbsp;</a></span>mqc_scalar_get_abs_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_get_abs_value </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Get_ABS_Value is a function that returns the absolute value of MQC_scalar variable</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Get_ABS_Value is a function that returns the absolute value 
    of MQC_scalar variable.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(MQC_Scalar)
        The MQC_Scalar to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>A. Mahler <br  />
 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2018 </dd></dl>

</div>
</div>
<a id="af2f017191f779ad512979693572104f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f017191f779ad512979693572104f7">&#9670;&nbsp;</a></span>mqc_scalar_get_intrinsic_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">complex(kind=real64) function mqc_algebra::mqc_scalar_get_intrinsic_complex </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Get_Intrinsic_Complex is a function that returns the MQC_scalar value as an intrinsic complex</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Get_Intrinsic_Complex is a function that returns the MQC_scalar 
    value as an intrinsic complex.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(MQC_Scalar)
        The MQC_Scalar to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="af71295f7ab29e9d87330ecd7fcc133d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71295f7ab29e9d87330ecd7fcc133d4">&#9670;&nbsp;</a></span>mqc_scalar_get_intrinsic_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind=int64) function mqc_algebra::mqc_scalar_get_intrinsic_integer </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Get_Intrinsic_Integer is a function that returns the MQC_scalar value as an intrinsic integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Get_Intrinsic_Integer is a function that returns the MQC_scalar 
    value as an intrinsic integer.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(MQC_Scalar)
        The MQC_Scalar to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a5b46fb61fbda788dfa6f3631c67fcac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b46fb61fbda788dfa6f3631c67fcac1">&#9670;&nbsp;</a></span>mqc_scalar_get_intrinsic_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64) function mqc_algebra::mqc_scalar_get_intrinsic_real </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Get_Intrinsic_Real is a function that returns the MQC_scalar value as an intrinsic real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Get_Intrinsic_Real is a function that returns the MQC_scalar 
    value as an intrinsic real.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(MQC_Scalar)
        The MQC_Scalar to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a7a974cc8a6293e353f55b61b8e3f80e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a974cc8a6293e353f55b61b8e3f80e0">&#9670;&nbsp;</a></span>mqc_scalar_get_random_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_scalar_get_random_value </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(:), optional&#160;</td>
          <td class="paramname"><em>Seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>Distribution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Get_Random_Value is a function that returns a random real value from a specified distribution</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Get_Random_Value is a function that returns a random real 
    value from an optionally specified distribution. Note that the range of
    values varies by distribution. In addition, a seed can be specified for 
    consistent greneration of the same number. Default options are uniform 
    distribution with random seed. The following options are available:
    
    1. Distribution = 'uniform' uses a uniform distribution between 0 and 1. 
    2. Distribution = 'gaussian' uses a normal distribution with zero mean and
                      unit variance obtained using the Box-Muller transformation
    3. Distribution = 'exp' uses an exponential distribution (lambda=1.0) 
                      returning positive integers. 
    4. Distribution = 'exp01' uses an exponential distribution (lambda=8.0)that 
                      gives values in the range 0 and 1. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(MQC_Scalar)
        The MQC_Scalar to be filled. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Seed</td><td><pre class="fragment">        Seed is integer,dimension(:),optional 
        Integer array containing seed. Note in gfortran
        only the first two elements affect the value of
        the random number.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Distribution</td><td><pre class="fragment">        Distribution is character(len=*),intent(in),optional 
        Distribution of the function from which random number
        is selected.
        = 'uniform':  uniform between 0 and 1
        = 'gaussian': normal deviation with zero mean and unit 
                      variance
        = 'exp':      exponential decay y=\exp(-x)
        = 'exp01':    exponential decay between 0 and 1 obtained
                      using mod(y,1.0) of y=\exp(-8x).</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Dong <br  />
 </dd>
<dd>
L. M. Thompson <br  />
 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a57212825ab5c80d980d69fc9f9d86611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57212825ab5c80d980d69fc9f9d86611">&#9670;&nbsp;</a></span>mqc_scalar_havecomplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalar_havecomplex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_HaveComplex is a function that returns TRUE or FALSE indicating whether an MQC_scalar is of type complex</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_HaveComplex is a function that returns TRUE or FALSE indicating 
    whether an MQC_scalar is of type complex.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ad4174a790e525f23d3f4bd73e8f29fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4174a790e525f23d3f4bd73e8f29fa1">&#9670;&nbsp;</a></span>mqc_scalar_haveinteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalar_haveinteger </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_HaveInteger is a function that returns TRUE or FALSE indicating whether an MQC_scalar is of type integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_HaveInteger is a function that returns TRUE or FALSE indicating 
    whether an MQC_scalar is of type integer.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a44f6c8700d153955e163ca7872c51dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f6c8700d153955e163ca7872c51dc7">&#9670;&nbsp;</a></span>mqc_scalar_havereal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalar_havereal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_HaveReal is a function that returns TRUE or FALSE indicating whether an MQC_scalar is of type real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_HaveReal is a function that returns TRUE or FALSE indicating 
    whether an MQC_scalar is of type real.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aa9fad6f7ddafdd868da867c57c6b7ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fad6f7ddafdd868da867c57c6b7ad4">&#9670;&nbsp;</a></span>mqc_scalar_isallocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalar_isallocated </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_IsAllocated is used to determine the allocation status of an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_IsAllocated is a subroutine used to determine the allocation status
    of an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The name of the MQC_Scalar variable to check allocation status.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a49d52c71bb3f25dd7c05d7dea7cf922b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d52c71bb3f25dd7c05d7dea7cf922b">&#9670;&nbsp;</a></span>mqc_scalar_sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_sin </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Sin is a function used to return the sine of an MQC_scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Sin is a function used to return the sine of an MQC_scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a48183353286c23747df863dd562aa8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48183353286c23747df863dd562aa8b8">&#9670;&nbsp;</a></span>mqc_scalar_sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_sqrt </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Sqrt is a function used to return the square root of an MQC_scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Sqrt is a function used to return the square root of an MQC_scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a860726fae10ec3b3f92451c5d4bfbc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860726fae10ec3b3f92451c5d4bfbc52">&#9670;&nbsp;</a></span>mqc_scalar_tan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalar_tan </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Scalar_Tan is a function used to return the tangent of an MQC_scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Scalar_Tan is a function used to return the tangent of an MQC_scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The argument of the function.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a7e549ede414a6f0b7d4533b532602eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e549ede414a6f0b7d4533b532602eac">&#9670;&nbsp;</a></span>mqc_scalaradd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalaradd </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarAdd is a function that sums two MQC_Scalar objects</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarAdd is a function that sums two MQC_Scalar objects.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar to be summed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar to be summed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ab9324f81f0ddb53ed3657042a1ca9a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9324f81f0ddb53ed3657042a1ca9a16">&#9670;&nbsp;</a></span>mqc_scalarcomplexadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarcomplexadd </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarComplexAdd is a function that is used to sum an intrinsic complex by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarComplexAdd is a function that is used to sum an intrinsic complex by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        Complex is Complex(kind=real64)
        The intrinsic complex variable to sum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variabel to sum.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a3d179bcbbe61d625060fc313863b9842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d179bcbbe61d625060fc313863b9842">&#9670;&nbsp;</a></span>mqc_scalarcomplexdivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarcomplexdivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarComplexDivide is a function that is used to divide an MQC_Scalar by an intrinsic complex</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarComplexDivide is a function that is used to divide an MQC_Scalar by an 
    intrinsic complex. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        ComplexIn is Complex(kind=real64)
        The intrinsic complex variable denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a441274a6033cb145846b8ad2025e87c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441274a6033cb145846b8ad2025e87c6">&#9670;&nbsp;</a></span>mqc_scalarcomplexexponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarcomplexexponent </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>CompIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarComplexExponent is a function that raises an MQC_Scalar to the power of an intrinsic complex</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarComplexExponent is a function that raises an MQC_Scalar to the power of an 
    intrinsic complex.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The base value.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CompIn</td><td><pre class="fragment">        CompIn is Complex(kind=real64)
        The power value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a4cf29d4cc0a3ec01a7c66bc796ae1562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf29d4cc0a3ec01a7c66bc796ae1562">&#9670;&nbsp;</a></span>mqc_scalarcomplexmultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarcomplexmultiply </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarComplexMultiply is a function that is used to multiply an intrinsic complex by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarComplexMultiply is a function that is used to multiply an intrinsic complex by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        Complex is Complex(kind=real64)
        The intrinsic complex variable to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variabel to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a90f607dd0cb298789506092e4d1a9593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f607dd0cb298789506092e4d1a9593">&#9670;&nbsp;</a></span>mqc_scalarcomplexsubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarcomplexsubtract </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>ComplexIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarComplexSubtract is a function that is used to subtract an intrinsic complex from an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarComplexSubtract is a function that is used to subtract an intrinsic complex
    from an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to subtract from.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ComplexIn</td><td><pre class="fragment">        ComplexIn is Complex(kind=real64)
        The intrinsic complex to subtract.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ac3544d5de10c82ed17fc39b359be9089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3544d5de10c82ed17fc39b359be9089">&#9670;&nbsp;</a></span>mqc_scalardivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalardivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarDivide is a function that divides two MQC_Scalar objects</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarDivide is a function that divides MQC_Scalar objects.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a9b654f9c495b768a42c40196b8a9188b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b654f9c495b768a42c40196b8a9188b">&#9670;&nbsp;</a></span>mqc_scalareq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalareq </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarEQ is a function that returns TRUE if two MQC_Scalar variables are equal</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarEQ is a function that returns TRUE if two MQC_Scalar variables 
    are equal.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a74199060019d514fa5064c354a479c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74199060019d514fa5064c354a479c96">&#9670;&nbsp;</a></span>mqc_scalarexponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarexponent </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarExponent is a function that raises one MQC_Scalar to the power of another MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarExponent is a function that raises one MQC_Scalar to the power of 
    another MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The base value.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The power value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a07b5159e0089cd791c245e99cbf3a1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b5159e0089cd791c245e99cbf3a1e3">&#9670;&nbsp;</a></span>mqc_scalarge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalarge </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarGE is a function that returns TRUE if the left MQC_Scalar is greater than or equal the right MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarGE is a function that returns TRUE if the left MQC_Scalar is greater than or
    equal to the right MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the left real part is
    is greater than or equal to the right real part and FALSE if the left real part is less
    than the right real part.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a4533fe7f7037b8a3d087346a008593e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4533fe7f7037b8a3d087346a008593e2">&#9670;&nbsp;</a></span>mqc_scalargt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalargt </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarGT is a function that returns TRUE if the left MQC_Scalar is greater than the right MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarGT is a function that returns TRUE if the left MQC_Scalar is greater than
    the right MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the left real part 
    is greater than the right real part and FALSE if the left real part is less than 
    the right real part. If the left real part is equal to the right real part, the 
    function returns TRUE if the left imaginary part is greater than the right imaginary 
    part and FALSE otherwise.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ad9f15df9068743c0e9ec802a07f9c736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f15df9068743c0e9ec802a07f9c736">&#9670;&nbsp;</a></span>mqc_scalargtinteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalargtinteger </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarGTInteger is a function that returns TRUE if a MQC_Scalar is greater than an intrinsic integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarGTInteger is a function that returns TRUE if a MQC_Scalar is greater than an 
    intrinsic integer.

    When dealing with complex numbers, the function returns TRUE if the real part of the 
    MQC_Scalar is greater than the intrinsic integer and FALSE if the real part of the 
    MQC_Scalar is less than the intrinsic integer. If the real part of the MQC_Scalar is 
    equal to the intrinsic integer, the function returns TRUE if the imaginary part of 
    MQC_Scalar is greater than zero and FALSE otherwise.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The intrinsic integer that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a74b3e0f81e6b62300e79a85b9a2820af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b3e0f81e6b62300e79a85b9a2820af">&#9670;&nbsp;</a></span>mqc_scalargtreal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalargtreal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarGTReal is a function that returns TRUE if a MQC_Scalar is greater than an intrinsic real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarGTReal is a function that returns TRUE if a MQC_Scalar is greater than an 
    intrinsic real.

    When dealing with complex numbers, the function returns TRUE if the real part of the 
    MQC_Scalar is greater than the intrinsic real and FALSE if the real part of the 
    MQC_Scalar is less than the intrinsic real. If the real part of the MQC_Scalar is 
    equal to the intrinsic real, the function returns TRUE if the imaginary part of 
    MQC_Scalar is greater than zero and FALSE otherwise. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=int64)
        The intrinsic real that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a2963d6cff1c4da599359df46e094770a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2963d6cff1c4da599359df46e094770a">&#9670;&nbsp;</a></span>mqc_scalarintegeradd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarintegeradd </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarIntegerAdd is a function that is used to sum an intrinsic integer by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarIntegerSum is a function that is used to sum an intrinsic integer by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer variable to sum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar varibale to sum.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ae1e83bd05393481b1d246858e38f7bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e83bd05393481b1d246858e38f7bf4">&#9670;&nbsp;</a></span>mqc_scalarintegerdivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarintegerdivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarIntegerDivide is a function that is used to divide an MQC_Scalar by an intrinsic integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarIntegerDivide is a function that is used to divide an MQC_Scalar by an 
    intrinsic integer.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer variable denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="af993c7e2cc78b87876c1c3cc9f8d9b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af993c7e2cc78b87876c1c3cc9f8d9b2e">&#9670;&nbsp;</a></span>mqc_scalarintegerexponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarintegerexponent </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarIntegerExponent is a function that raises an MQC_Scalar to the power of an intrinsic integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarIntegerExponent is a function that raises an MQC_Scalar to the power of an 
    intrinsic integer.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The base value.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The power value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a3e4acb398a6dad0fda3d3ddbfd78898b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4acb398a6dad0fda3d3ddbfd78898b">&#9670;&nbsp;</a></span>mqc_scalarintegermultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarintegermultiply </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarIntegerMultiply is a function that is used to multiply an intrinsic integer by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarIntegerMultiply is a function that is used to multiply an intrinsic integer by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer variable to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar varibale to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ac8c67de0d6d4853006e5855382de532c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c67de0d6d4853006e5855382de532c">&#9670;&nbsp;</a></span>mqc_scalarintegersubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarintegersubtract </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntegerIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarIntegerSubtract is a function that is used to subtract an intrinsic integer from an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarIntegerSubtract is a function that is used to subtract an intrinsic integer
    from an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to subtract from.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IntegerIn</td><td><pre class="fragment">        IntegerIn is Integer(kind=int64)
        The intrinsic integer to subtract.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a72b9aaef343779f7ec75161b6e62edfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b9aaef343779f7ec75161b6e62edfe">&#9670;&nbsp;</a></span>mqc_scalarle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalarle </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarLE is a function that returns TRUE if the left MQC_Scalar is less than or equal the right MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarLE is a function that returns TRUE if the left MQC_Scalar is less than or
    equal to the right MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the left real part 
    is less than or equal to the right real part and FALSE if the left real part is greater 
    than the right real part.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a86c752a369012f86a452b8fc6c3c1ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c752a369012f86a452b8fc6c3c1ad0">&#9670;&nbsp;</a></span>mqc_scalarleinteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalarleinteger </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>IntIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarLEInteger is a function that returns TRUE if a MQC_Scalar is less than or equal to an intrinsic integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarLEInteger is a function that returns TRUE if a MQC_Scalar is less than or 
    equal to an intrinsic integer.

    When dealing with complex numbers, the function returns TRUE if the real part of the 
    MQC_Scalar is less than or equal to the intrinsic integer and FALSE if the real part 
    of the MQC_Scalar is greater than the intrinsic integer. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The intrinsic integer that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a1998cf7bec418ce41907712998634d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1998cf7bec418ce41907712998634d88">&#9670;&nbsp;</a></span>mqc_scalarlereal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalarlereal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarLEReal is a function that returns TRUE if a MQC_Scalar is less than or equal to an intrinsic real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarLEReal is a function that returns TRUE if a MQC_Scalar is less than or equal to
    an intrinsic real.

    When dealing with complex numbers, the function returns TRUE if the real part of the 
    MQC_Scalar is less than or equal to the intrinsic real and FALSE if the real part of the 
    MQC_Scalar is greater than the intrinsic real.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=int64)
        The intrinsic real that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a671f760b8ee1ec7373259ae83057116f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671f760b8ee1ec7373259ae83057116f">&#9670;&nbsp;</a></span>mqc_scalarlt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalarlt </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarLT is a function that returns TRUE if the left MQC_Scalar is less than the right MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarLT is a function that returns TRUE if the left MQC_Scalar is less than
    the right MQC_Scalar. 

    When dealing with complex numbers, the function returns TRUE if the left real part 
    is less than the right real part and FALSE if the left real part is greater than 
    the right real part. If the left real part is equal to the right real part, the 
    function returns TRUE if the left imaginary part is less than the right imaginary 
    part and FALSE otherwise. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a956c2239f00621becee82131328d1eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956c2239f00621becee82131328d1eaf">&#9670;&nbsp;</a></span>mqc_scalarltreal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalarltreal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarLTReal is a function that returns TRUE if a MQC_Scalar is less than an intrinsic real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarLTReal is a function that returns TRUE if a MQC_Scalar is less than an 
    intrinsic real.

    When dealing with complex numbers, the function returns TRUE if the real part of the 
    MQC_Scalar is less than the intrinsic real and FALSE if the real part of the MQC_Scalar
    is greater than the intrinsic real. If the real part of the MQC_Scalar is equal to the
    intrinsic real, the function returns TRUE if the imaginary part of MQC_Scalar is less 
    than zero and FALSE otherwise. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a0f25321d9656a01ab64b54e3b44663f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f25321d9656a01ab64b54e3b44663f0">&#9670;&nbsp;</a></span>mqc_scalarmatrixproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_scalarmatrixproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarMatrixProduct is a function that computes the product of a MQC matrix and a MQC scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarMatrixProduct is a function that computes the product of a MQC matrix
    and a MQC scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC scalar to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Matrix</td><td><pre class="fragment">        Matrix is Type(MQC_Matrix)
        The MQC matrix to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ab3bb7eafe1ebcfc572969d1677eefbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bb7eafe1ebcfc572969d1677eefbff">&#9670;&nbsp;</a></span>mqc_scalarmultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarmultiply </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarMultiply is a function that multiplies two MQC_Scalar objects</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarMultiply is a function that multiplies two MQC_Scalar objects.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar to be multiplied.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar to be multiplied.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="afa9d3434fe330c47bfa7428974e77ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9d3434fe330c47bfa7428974e77ec5">&#9670;&nbsp;</a></span>mqc_scalarne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_scalarne </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarNE is a function that returns TRUE if two MQC_Scalar variables are not equal</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarNE is a function that returns TRUE if two MQC_Scalar variables 
    are not equal.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar that will be tested.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar that will be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="aa45c4db95c648b8ce5d240d7b1198be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45c4db95c648b8ce5d240d7b1198be4">&#9670;&nbsp;</a></span>mqc_scalarrealadd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarrealadd </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarRealAdd is a function that is used to sum an intrinsic real by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarRealSum is a function that is used to sum an intrinsic real by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">realIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real variable to sum.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to sum.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a341525976717733d32c5ba56b9a585b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341525976717733d32c5ba56b9a585b8">&#9670;&nbsp;</a></span>mqc_scalarrealdivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarrealdivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarRealDivide is a function that is used to divide an MQC_Scalar by an intrinsic real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarRealDivide is a function that is used to divide an MQC_Scalar by an 
    intrinsic real. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable numerator.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real variable denominator.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="affd6b4aad86126fe0ae97e65f1e19a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd6b4aad86126fe0ae97e65f1e19a00">&#9670;&nbsp;</a></span>mqc_scalarrealexponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarrealexponent </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarRealExponent is a function that raises an MQC_Scalar to the power of an intrinsic real</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarRealExponent is a function that raises an MQC_Scalar to the power of an 
    intrinsic real.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The base value.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The power value.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a23cbafa5e66d0700c76e4157189c9095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cbafa5e66d0700c76e4157189c9095">&#9670;&nbsp;</a></span>mqc_scalarrealmultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarrealmultiply </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarRealMultiply is a function that is used to multiply an intrinsic real by an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarRealMultiply is a function that is used to multiply an intrinsic real by
    an MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">realIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real variable to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a5e4d3df27b95d21dab20b1c7024aba61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4d3df27b95d21dab20b1c7024aba61">&#9670;&nbsp;</a></span>mqc_scalarrealsubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarrealsubtract </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>RealIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarRealSubtract is a function that is used to subtract an intrinsic real from an MQC_Scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarRealSubtract is a function that is used to subtract an intrinsic real from an
    MQC_Scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar variable to subtract from.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real to subtract.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ab142473388c5cc3a397b64224eb3befa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab142473388c5cc3a397b64224eb3befa">&#9670;&nbsp;</a></span>mqc_scalarsubtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_scalarsubtract </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarSubtract is a function that subtracts two MQC_Scalar objects</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarSubtract is a function that subtracts two MQC_Scalar objects.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar1</td><td><pre class="fragment">        Scalar1 is Type(MQC_Scalar)
        The first MQC_Scalar from which Scalar2 will be subtracted.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar2</td><td><pre class="fragment">        Scalar2 is Type(MQC_Scalar)
        The second MQC_Scalar which will be subtracted from Scalar1.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="acc3b73dd48c7cab051876b9577877366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3b73dd48c7cab051876b9577877366">&#9670;&nbsp;</a></span>mqc_scalarvectordifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_scalarvectordifference </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarVectorDifference is a function that subtracts an MQC scalar from all elements of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarVectorDifference is a function that subtracts an MQC scalar from 
    all elements of an MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar)
        The MQC scalar to be subtracted from elements of the
        the MQC vector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Type(MQC_Vector)
        The MQC vector with elements from which ScalarIn will
        be subtracted.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a5420193880824d24e30705966cab1a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5420193880824d24e30705966cab1a9b">&#9670;&nbsp;</a></span>mqc_scalarvectorproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_scalarvectorproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarVectorProduct is a function that returns the product of a MQC scalar with a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_ScalarVectorProduct is a function that returns the product of a MQC scalar 
    with a MQC vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to multiply. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng <br  />
 </dd>
<dd>
A. D. Mahler <br  />
 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017, 2019 </dd></dl>

</div>
</div>
<a id="a98fc4e9fe5034154c95a4b15725aa0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fc4e9fe5034154c95a4b15725aa0ec">&#9670;&nbsp;</a></span>mqc_scalarvectorsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_scalarvectorsum </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>ScalarIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_ScalarVectorSum is a function that adds an MQC scalar to all elements of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorVectorSum is a function that adds an MQC scalar to all elements of 
    an MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ScalarIn</td><td><pre class="fragment">        ScalarIn is Type(MQC_Scalar)
        The MQC scalar to add to the MQC vector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Type(MQC_Vector)
        The MQC vector with elements to sum with ScalarIn.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a21dc9134fedc47e63403ea816ad243cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21dc9134fedc47e63403ea816ad243cd">&#9670;&nbsp;</a></span>mqc_set_array2tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_array2tensor </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__r4tensor.html">mqc_r4tensor</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>TensorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(*), dimension(:,:,:,:), intent(in)&#160;</td>
          <td class="paramname"><em>ArrayIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d1a623e6244dccb485b3420d23ba38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1a623e6244dccb485b3420d23ba38b">&#9670;&nbsp;</a></span>mqc_set_array2vector_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_array2vector_complex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>VectorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>ArrayIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Array2Vector_Complex is a subroutine that sets a rank 1 vector intrinsic complex array equal to a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Array2Vector_Complex is a subroutine that sets a rank 1 vector intrinsic
    complex array equal to a MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VectorOut</td><td><pre class="fragment">        VectorOut is Type(MQC_Vector)
        The MQC vector that will be set equal to the rank 1 
        intrinsic array </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ArrayIn</td><td><pre class="fragment">        ArrayOut is Complex(kind=real64),Dimension(:)
        The rank 1 intrinsic array whose data will be input 
        into the MQC vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ab0b93cf3b8fade6272fee7b028f55006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b93cf3b8fade6272fee7b028f55006">&#9670;&nbsp;</a></span>mqc_set_array2vector_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_array2vector_integer </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>VectorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>ArrayIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Array2Vector_Integer is a subroutine that sets a rank 1 intrinsic integer array equal to a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Array2Vector_Integer is a subroutine that sets a rank 1 intrinsic 
    integer array equal to a MQC vector</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VectorOut</td><td><pre class="fragment">        VectorOut is Type(MQC_Vector)
        The MQC vector that will be set equal to the rank 1 
        intrinsic array </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ArrayIn</td><td><pre class="fragment">        ArrayOut is Integer(kind=int64),Dimension(:)
        The rank 1 intrinsic array whose data will be input 
        into the MQC vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a26cf2c2384fcf4256bdc24f147c99f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cf2c2384fcf4256bdc24f147c99f70">&#9670;&nbsp;</a></span>mqc_set_array2vector_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_array2vector_real </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>VectorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>ArrayIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Array2Vector_Real is a subroutine that sets a rank 1 vector intrinsic real array equal to a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Array2Vector_Real is a subroutine that sets a rank 1 vector intrinsic
    real array equal to a MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VectorOut</td><td><pre class="fragment">        VectorOut is Type(MQC_Vector)
        The MQC vector that will be set equal to the rank 1 
        intrinsic array </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ArrayIn</td><td><pre class="fragment">        ArrayOut is Real(kind=real64),Dimension(:)
        The rank 1 intrinsic array whose data will be input 
        into the MQC vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ae9a5a36d7be18f1b190240fd8a7ab81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a5a36d7be18f1b190240fd8a7ab81e">&#9670;&nbsp;</a></span>mqc_set_complexarray2matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_complexarray2matrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>MatrixOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), dimension(:,:), intent(in)&#160;</td>
          <td class="paramname"><em>ArrayIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_ComplexArray2Matrix is a subroutine that sets an MQC matrix equal to an intrinsic complex rank-2 array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_ComplexArray2Matrix is a subroutine that sets an MQC matrix equal to an
    intrinsic complex rank-2 array.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MatrixOut</td><td><pre class="fragment">        MatrixOut is Type(MQC_Matrix)
        The MQC matrix to be set equal to the complex array.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ArrayIn</td><td><pre class="fragment">        ArrayIn is Complex(kind=real64),Dimension(:,:)
        The complex array to be input into MatrixOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a20d7a2397ab1d86b82d757a197137ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d7a2397ab1d86b82d757a197137ab7">&#9670;&nbsp;</a></span>mqc_set_integerarray2matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_integerarray2matrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>MatrixOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), dimension(:,:), intent(in)&#160;</td>
          <td class="paramname"><em>ArrayIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_IntegerArray2Matrix is a subroutine that sets an MQC matrix equal to an intrinsic integer rank-2 array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_IntegerArray2Matrix is a subroutine that sets an MQC matrix equal to an
    intrinsic integer rank-2 array.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MatrixOut</td><td><pre class="fragment">        MatrixOut is Type(MQC_Matrix)
        The MQC matrix to be set equal to the integer array.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ArrayIn</td><td><pre class="fragment">        ArrayIn is Integer(kind=int64),Dimension(:,:)
        The integer array to be input into MatrixOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ab99c5a9550ff2979949b3f89070f6afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99c5a9550ff2979949b3f89070f6afb">&#9670;&nbsp;</a></span>mqc_set_matrix2complexarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_matrix2complexarray </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), dimension(:,:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>ArrayOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Matrix2ComplexArray is a subroutine that sets an intrinsic complex rank-2 array equal to an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Matrix2ComplexArray is a subroutine that sets an intrinsic complex 
    rank-2 array equal to an MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ArrayOut</td><td><pre class="fragment">        ArrayOut is Complex(kind=real64),Dimension(:,:),Allocatable
        The complex array to be set equal to the MQC matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MatrixIn</td><td><pre class="fragment">        MatrixIn is Type(MQC_Matrix)
        The MQC matrix to be input into ArrayOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a8204520d32c6bfe3cee8aa2d50b65274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8204520d32c6bfe3cee8aa2d50b65274">&#9670;&nbsp;</a></span>mqc_set_matrix2integerarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_matrix2integerarray </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), dimension(:,:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>ArrayOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Matrix2IntegerArray is a subroutine that sets an intrinsic integer rank-2 array equal to an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Matrix2IntegerArray is a subroutine that sets an intrinsic integer 
    rank-2 array equal to an MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ArrayOut</td><td><pre class="fragment">        ArrayOut is Integer(kind=int64),Dimension(:,:),Allocatable
        The integer array to be set equal to the MQC matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MatrixIn</td><td><pre class="fragment">        MatrixIn is Type(MQC_Matrix)
        The MQC matrix to be input into ArrayOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a15a783566c4891b64f8e83fee736ba20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a783566c4891b64f8e83fee736ba20">&#9670;&nbsp;</a></span>mqc_set_matrix2matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_matrix2matrix </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>MatrixOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Matrix2Matrix is a subroutine that sets an MQC matrix equal to another MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Matrix2Matrix is a subroutine that sets an MQC matrix equal to another 
    MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MatrixOut</td><td><pre class="fragment">        MatrixOut is Class(MQC_Matrix)
        The MQC matrix to be set equal to the incoming MQC 
        matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MatrixIn</td><td><pre class="fragment">        MatrixIn is Class(MQC_Matrix)
        The MQC matrix to be input into MatrixOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a544f1ff194490228f18d7198a4baeecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544f1ff194490228f18d7198a4baeecc">&#9670;&nbsp;</a></span>mqc_set_matrix2realarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_matrix2realarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:,:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>ArrayOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MatrixIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Matrix2RealArray is a subroutine that sets an intrinsic real rank-2 array equal to an MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Matrix2RealArray is a subroutine that sets an intrinsic real rank-2 
    array equal to an MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ArrayOut</td><td><pre class="fragment">        ArrayOut is Real(kind=real64),Dimension(:,:),Allocatable
        The real array to be set equal to the MQC matrix.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MatrixIn</td><td><pre class="fragment">        MatrixIn is Type(MQC_Matrix)
        The MQC matrix to be input into ArrayOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ac220bbbae4694f6402442c9155322869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac220bbbae4694f6402442c9155322869">&#9670;&nbsp;</a></span>mqc_set_realarray2matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_realarray2matrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>MatrixOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:,:), intent(in)&#160;</td>
          <td class="paramname"><em>ArrayIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_RealArray2Matrix is a subroutine that sets an MQC matrix equal to an intrinsic real rank-2 array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_RealArray2Matrix is a subroutine that sets an MQC matrix equal to an
    intrinsic real rank-2 array.    </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">MatrixOut</td><td><pre class="fragment">        MatrixOut is Type(MQC_Matrix)
        The MQC matrix to be set equal to the real array.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ArrayIn</td><td><pre class="fragment">        ArrayIn is Real(kind=real64),Dimension(:,:)
        The real array to be input into MatrixOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a69e6f949ac09346185c019c7217b92fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e6f949ac09346185c019c7217b92fb">&#9670;&nbsp;</a></span>mqc_set_vector2complexarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_vector2complexarray </td>
          <td>(</td>
          <td class="paramtype">complex(kind=real64), dimension(:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>ArrayOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Vector2ComplexArray is a subroutine that outputs an MQC vector to a rank 1 intrinsic complex array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Vector2ComplexArray is a subroutine that outputs an MQC vector to
    a rank 1 intrinsic complex array. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ArrayOut</td><td><pre class="fragment">        ArrayOut is Complex(kind=real64),Dimension(:)
        The rank 1 intrinsic array which will receive the contents
        of MQC_Vector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Type(MQC_Vector)
        The MQC_Vector whose data will be output into the intrinsic
        array.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aba54eb450ce211317b02ef6f33ac2e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba54eb450ce211317b02ef6f33ac2e4b">&#9670;&nbsp;</a></span>mqc_set_vector2integerarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_vector2integerarray </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), dimension(:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>ArrayOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Vector2IntegerArray is a subroutine that outputs an MQC vector to a rank 1 intrinsic integer array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Vector2IntegerArray is a subroutine that outputs an MQC vector to
    a rank 1 intrinsic integer array. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ArrayOut</td><td><pre class="fragment">        ArrayOut is Integer(kind=int64),Dimension(:)
        The rank 1 intrinsic array which will receive the contents
        of MQC_Vector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Type(MQC_Vector)
        The MQC_Vector whose data will be output into the intrinsc
        array.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a2c87333d1d226be9235bd76ed6dc8e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c87333d1d226be9235bd76ed6dc8e14">&#9670;&nbsp;</a></span>mqc_set_vector2realarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_vector2realarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), dimension(:), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>ArrayOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Vector2RealArray is a subroutine that outputs an MQC vector to a rank 1 intrinsic real array</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Vector2RealArray is a subroutine that outputs an MQC vector to
    a rank 1 intrinsic real array. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ArrayOut</td><td><pre class="fragment">        ArrayOut is Real(kind=real64),Dimension(:)
        The rank 1 intrinsic array which will receive the contents
        of MQC_Vector.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Type(MQC_Vector)
        The MQC_Vector whose data will be output into the intrinsic
        array.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a51a7b85f2e0c573ff40f6af97eb6cfac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a7b85f2e0c573ff40f6af97eb6cfac">&#9670;&nbsp;</a></span>mqc_set_vector2vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_set_vector2vector </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>VectorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Set_Vector2Vector is a subroutine that sets a MQC vector equal to another MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Set_Vector2Vector is a subroutine that sets a MQC vector equal to another 
    MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VectorOut</td><td><pre class="fragment">        VectorOut is Type(MQC_Vector)
        The MQC vector that will be set equal to VectorIn.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Type(MQC_Vector)
        The MQC vector whose contents will be copied to 
        VectorOut.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd>
<dd>
L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ab8156b61ed2a139980ac838ddb4bf66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8156b61ed2a139980ac838ddb4bf66a">&#9670;&nbsp;</a></span>mqc_vector2diagmatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>) function mqc_algebra::mqc_vector2diagmatrix </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector2DiagMatrix is a function that outputs a diagonal MQC matrix with elements defined by an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector2DiagMatrix is a function that outputs a diagonal MQC matrix with
    elements defined by an MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        MQC vector defining diagonal elements of output matrix.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a06f8fcdd90b4dfb27df7aea1a5443aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f8fcdd90b4dfb27df7aea1a5443aa6">&#9670;&nbsp;</a></span>mqc_vector_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_abs </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Abs is a function that returns the absolute value of all elements of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Sqrt is a function that returns the absolute value of all elements 
    of an MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a453aaae4a21eac2ab290bcf63fca9137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453aaae4a21eac2ab290bcf63fca9137">&#9670;&nbsp;</a></span>mqc_vector_argsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_argsort </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Argsort is a function that returns the indices of an an MQC vector sorted from low to high</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Argsort is a function that returns the indices of an MQC vector
    sorted from low to high.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a1a198620593d0a313eaff6785965b265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a198620593d0a313eaff6785965b265">&#9670;&nbsp;</a></span>mqc_vector_cast_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_cast_complex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_vector_cast_complex is a function that converts an MQC vector to its complex space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_vector_cast_complex is a function that converts an MQC vector to its 
    complex space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td><pre class="fragment">        VA is Class(MQC_Vector)
        The MQC vector to convert.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a61df3eda09029cbe0513af750f9480a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61df3eda09029cbe0513af750f9480a3">&#9670;&nbsp;</a></span>mqc_vector_cast_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_cast_integer </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_vector_cast_integer is a function that converts an MQC vector to its integer space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_vector_cast_integer is a function that converts an MQC vector to its 
    integer space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td><pre class="fragment">        VA is Type(MQC_Vector)
        The MQC vector to convert.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a6ba4f662b816b4c95332885c0846548b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba4f662b816b4c95332885c0846548b">&#9670;&nbsp;</a></span>mqc_vector_cast_real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_cast_real </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_vector_cast_real is a function that converts an MQC vector to its real space</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_vector_cast_real is a function that converts an MQC vector to its real 
    space.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td><pre class="fragment">        VA is Class(MQC_Vector)
        The MQC vector to convert.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a8d9392e173bbf919161ae62056ea02bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9392e173bbf919161ae62056ea02bc">&#9670;&nbsp;</a></span>mqc_vector_cmplx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_cmplx </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Cmplx is a function that takes a MQC vector representing the real part and a MQC vector representing the imaginary part and combines them into another MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Cmplx is a function that takes a MQC vector representing the real 
    part and a MQC vector representing the imaginary part and combines them into 
    another MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector1</td><td><pre class="fragment">        Vector1 is Type(MQC_Vector)
        The MQC vector containing the real part.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector2</td><td><pre class="fragment">        Vector2 is Type(MQC_Vector)
        The MQC vector containing the imaginary part.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ac0f5b609f9905e81c158cfabc59ba995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f5b609f9905e81c158cfabc59ba995">&#9670;&nbsp;</a></span>mqc_vector_complex_imagpart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_complex_imagpart </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Complex_ImagPart is a function that returns a MQC vector with elements containing the imaginary part of elements of another MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Complex_ImagPart is a function that returns a MQC vector with 
    elements containing the imaginary part of elements of another MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a455f7d692b63256f00e891310159eff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455f7d692b63256f00e891310159eff5">&#9670;&nbsp;</a></span>mqc_vector_complex_realpart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_complex_realpart </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Complex_RealPart is a function that returns a MQC vector with elements containing the real part of elements of another MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Complex_RealPart is a function that returns a MQC vector with 
    elements containing the real part of elements of another MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a5cc43bf9008f4f5892e2a87eab2786d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc43bf9008f4f5892e2a87eab2786d3">&#9670;&nbsp;</a></span>mqc_vector_conjugate_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_conjugate_transpose </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Conjugate_Transpose is a function that returns the conjugate transpose of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Conjugate_Transpose is a function that returns the conjugate 
    transpose of an MQC vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC vector to conjugate transpose.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a247f4f9eb21c9089b2c6d60f72e700f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247f4f9eb21c9089b2c6d60f72e700f9">&#9670;&nbsp;</a></span>mqc_vector_copy_complex2int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_copy_complex2int </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Copy_Complex2Int is a subroutine that copies a complex MQC_Vector into its integer vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Copy_Complex2Int is a subroutine that copies a complex MQC_Vector
    into its integer vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a0c3a91a9b2e51be275947da30967b0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3a91a9b2e51be275947da30967b0e5">&#9670;&nbsp;</a></span>mqc_vector_copy_complex2real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_copy_complex2real </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Copy_Complex2Real is a subroutine that copies a complex MQC_Vector into its real vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Copy_Complex2Real is a subroutine that copies a complex MQC_Vector
    into its real vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="addbe04990f7d7761d05d318fb6e87ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbe04990f7d7761d05d318fb6e87ecd">&#9670;&nbsp;</a></span>mqc_vector_copy_int2complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_copy_int2complex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Copy_Int2Complex is a subroutine that copies an integer MQC_Vector into its complex vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Copy_Int2Complex is a subroutine that copies an integer MQC_Vector 
    into its complex vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a4fbee00cc9b309180fa565476e23998c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbee00cc9b309180fa565476e23998c">&#9670;&nbsp;</a></span>mqc_vector_copy_int2real()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_copy_int2real </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Copy_Int2Real is a subroutine that copies an integer MQC_Vector into its real vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Copy_Int2Real is a subroutine that copies an integer MQC_Vector 
    into its real vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="aad819f9da223284d2f47c9a9e1f3c6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad819f9da223284d2f47c9a9e1f3c6fa">&#9670;&nbsp;</a></span>mqc_vector_copy_real2complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_copy_real2complex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Copy_Real2Complex is a subroutine that copies a real MQC_Vector into its complex vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Copy_Real2Complex is a subroutine that copies a real MQC_Vector
    into its complex vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aefc2c3e1e2114b24ffc435bb61d77f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc2c3e1e2114b24ffc435bb61d77f45">&#9670;&nbsp;</a></span>mqc_vector_copy_real2int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_copy_real2int </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Copy_Real2Int is a subroutine that copies a real MQC_Vector into its integer vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Copy_Real2Int is a subroutine that copies a real MQC_Vector into its
    integer vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a6874ea143732147d6c425c509c642038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6874ea143732147d6c425c509c642038">&#9670;&nbsp;</a></span>mqc_vector_havecomplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_vector_havecomplex </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_HaveComplex is a function that returns TRUE or FALSE indicating whether the MQC vector has an allocated complex vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_HaveComplex is a function that returns TRUE or FALSE indicating 
    whether the MQC vector has an allocated complex vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a32be9b1de2925fa4a4468ddeaea79485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32be9b1de2925fa4a4468ddeaea79485">&#9670;&nbsp;</a></span>mqc_vector_haveinteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_vector_haveinteger </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_HaveInteger is a function that returns TRUE or FALSE indicating whether the MQC vector has an allocated integer vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_HaveInteger is a function that returns TRUE or FALSE indicating 
    whether the MQC vector has an allocated integer vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a5f0fdcc4b2036d9450895868acce7737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0fdcc4b2036d9450895868acce7737">&#9670;&nbsp;</a></span>mqc_vector_havereal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_vector_havereal </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_HaveReal is a function that returns TRUE or FALSE indicating whether the MQC vector has an allocated real vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_HaveReal is a function that returns TRUE or FALSE indicating 
    whether the MQC vector has an allocated real vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="a31fd19e8ff539e406535c3b241049d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fd19e8ff539e406535c3b241049d2f">&#9670;&nbsp;</a></span>mqc_vector_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_initialize </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(*), optional&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Initialize is a subroutine that initializes a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Initialize is a subroutine that initializes a MQC vector. Default
    element values are 0.0, or otherwise vector can be initialized with optional
    argument.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The MQC_Vector to intialize.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td><pre class="fragment">        Length is Integer(kind=int64)
        The length to initialize vector</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Class(*),Optional
        Value to set each element of Vector. If not present,
        the value is set to 0.0. Can be of type integer, real,
        complex or MQC_Scalar.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a286a8b64267a598e6dcf03b66d0dbed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286a8b64267a598e6dcf03b66d0dbed3">&#9670;&nbsp;</a></span>mqc_vector_isallocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_vector_isallocated </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_isAllocated is a function that returns TRUE is an MQC vector is allocated and FALSE if it is not</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_isAllocated is a function that returns TRUE is an MQC vector is 
    allocated and FALSE if it is not.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a44658ecaa7703ab847e67e9d625afcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44658ecaa7703ab847e67e9d625afcf2">&#9670;&nbsp;</a></span>mqc_vector_iscolumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical function mqc_algebra::mqc_vector_iscolumn </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_IsColumn is a function that returns TRUE if the MQC vector is a column vector and FALSE if the MQC vector is a row vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_IsColumn is a function that returns TRUE if the MQC vector is a
    column vector and FALSE if the MQC vector is a row vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to be tested.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="adf93471010696ea87f0b68274f32eebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf93471010696ea87f0b68274f32eebe">&#9670;&nbsp;</a></span>mqc_vector_maxloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer function mqc_algebra::mqc_vector_maxloc </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_MaxLoc is a function that returns the index of the largest value in an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_MaxLoc is a function that returns the index of the largest value in 
    an MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a8dc37e00be3bd370224f16b0695f5c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc37e00be3bd370224f16b0695f5c07">&#9670;&nbsp;</a></span>mqc_vector_maxval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_vector_maxval </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_MaxVal is a function that returns the largest value in <br  />
 an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_MaxVal is a function that returns the largest value in an MQC 
    vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="aa46755babebe52ca491d14456a4e8596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46755babebe52ca491d14456a4e8596">&#9670;&nbsp;</a></span>mqc_vector_minloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer function mqc_algebra::mqc_vector_minloc </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_MinLoc is a function that returns the index of the smallest value in an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_MinLoc is a function that returns the index of the smallest value 
    in an MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="aabcb11421e77fd4c0a249b0a2303eb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcb11421e77fd4c0a249b0a2303eb9d">&#9670;&nbsp;</a></span>mqc_vector_minval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_vector_minval </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_MinVal is a function that returns the smallest value in <br  />
 an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_MinVal is a function that returns the smallest value in an MQC 
    vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="abe28acc2e8c2877cd034cb34218407a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe28acc2e8c2877cd034cb34218407a5">&#9670;&nbsp;</a></span>mqc_vector_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_vector_norm </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=1), intent(in), optional&#160;</td>
          <td class="paramname"><em>methodIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Norm is a function that returns the norm of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Norm is a function that returns the norm of an MQC vector. The 
    following options are available:

    1. methodIn = 'M' uses the maximum absolute value max(abs(A(i))).
    2. methodIn = '1' uses the one norm.
    3. methodIn = 'I' uses the infinity norm.
    4. methodIn = 'F' uses the Frobenius norm (default).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MethodIn</td><td><pre class="fragment">        MethodIn is Character(len=1)
        = 'M': max(abs(A(i)))
        = '1': one norm
        = 'I': infinity norm
        = 'F': Frobenius norm.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="af293100432345fe20c1a1d501c0657aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af293100432345fe20c1a1d501c0657aa">&#9670;&nbsp;</a></span>mqc_vector_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_vector_pop </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Pop is a function that removes a value from the end of a MQC vector and returns it</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Pop is a function that removes a value from the end of a MQC vector 
    and returns it.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a39efdd4b5c3a15ce5aa22df8e9a6de15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39efdd4b5c3a15ce5aa22df8e9a6de15">&#9670;&nbsp;</a></span>mqc_vector_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_power </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(*)&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Power is a function that returns the value of all elements of an MQC vector raised to a power</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Power is a function that returns the value of all elements of an 
    MQC vector raised to a power. The power can be integer, real, complex or an
    MQC scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td><pre class="fragment">        P is Class(*)
        The power to raise elements of the MQC vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ab4440f8788b00f8527ef996e66361d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4440f8788b00f8527ef996e66361d45">&#9670;&nbsp;</a></span>mqc_vector_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_push </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Push is a function that adds a value to the end of a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Push is a function that adds a value to the end of a MQC vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar) 
        The value that will be added to the end of Vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ac096d0ab43b725951c3c8e88c54ae87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac096d0ab43b725951c3c8e88c54ae87b">&#9670;&nbsp;</a></span>mqc_vector_scalar_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_vector_scalar_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Scalar_At is a function that returns the ith element of a MQC vector as an MQC scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Scalar_At is a function that returns the ith element of a MQC vector 
    as an MQC scalar. If the location of the element is negative the it is counted
    from the end of MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td><pre class="fragment">        Vec is Class(MQC_Vector)
        The MQC_Vector to extract the Ith element.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">        I is Integer(kind=int64)
        The location of the element in Vec to return. If I is 
        negative it is counted from the last element of Vec.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a5480b04f0bfad9017db7be94bdb335be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5480b04f0bfad9017db7be94bdb335be">&#9670;&nbsp;</a></span>mqc_vector_scalar_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_scalar_increment </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Scalar_Increment is a subroutine that increments the value of the ith element of a MQC vector by the value of a MQC scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Scalar_Increment is a subroutine that increments the value of the 
    ith element of a MQC vector by the value of a MQC scalar. If the location of 
    the element is negative then it is counted from the end of MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The MQC_Vector to update at the Ith element.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to update the Ith element.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">        I is Integer(kind=int64)
        The location of the element in Vector to update. If I
        is negative it is counted from the last element of 
        Vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a91796a634294803d77c56f70789ee4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91796a634294803d77c56f70789ee4fe">&#9670;&nbsp;</a></span>mqc_vector_scalar_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_scalar_put </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Scalar_Put is a subroutine that updates the value of the ith element of a MQC vector with the value of a MQC scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Scalar_Put is a subroutine that updates the value of the ith element
    of a MQC vector with the value of a MQC scalar. If the location of the element 
    is negative then it is counted from the end of MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The MQC_Vector to update at the Ith element.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to update Vector at element I.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">        I is Integer(kind=int64)
        The location of the element in Vector to update. If I
        is negative it is counted from the last element of 
        Vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a854a27f3bcffbca9cdfe591a73faa501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854a27f3bcffbca9cdfe591a73faa501">&#9670;&nbsp;</a></span>mqc_vector_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_vector_shift </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Shift is a function that removes a value from the beginning of a MQC vector and returns it</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Pop is a function that removes a value from the beginning of a MQC 
    vector and returns it.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="ac6e6a2d0e61a13ff688617643aafff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e6a2d0e61a13ff688617643aafff21">&#9670;&nbsp;</a></span>mqc_vector_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_sort </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Sort is a function that returns an MQC vector sorted from low to high unless optional index order is present</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Sort is a function that returns an MQC vector sorted from low to 
    high unless optional argument idx is present which gives the new order of the 
    vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td><pre class="fragment">        idx is Type(MQC_Vector),Optional
        The new order of indices after sort. </pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="ac5c9d9461701d7c247ed0f4bd48a68ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c9d9461701d7c247ed0f4bd48a68ac">&#9670;&nbsp;</a></span>mqc_vector_sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_sqrt </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Sqrt is a function that returns the square root of all elements of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Sqrt is a function that returns the square root of all elements of
    an MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td><pre class="fragment">        A is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a60686c80235aa8e05e96c69b25ee0196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60686c80235aa8e05e96c69b25ee0196">&#9670;&nbsp;</a></span>mqc_vector_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_transpose </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Transpose is a function that returns the transpose of an MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Transpose is a function that returns the transpose of an MQC vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC vector to transpose.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="ae1d92908367908d5f07c2696808668da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d92908367908d5f07c2696808668da">&#9670;&nbsp;</a></span>mqc_vector_unshift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_unshift </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Unshift is a function that adds a value to the beginning of a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Unshift is a function that adds a value to the beginning of a MQC 
    vector. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The name of the MQC_Vector variable.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar) 
        The value that will be added to the beginning of Vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="accbfce3ed0b451faac3b15c6fbee1732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbfce3ed0b451faac3b15c6fbee1732">&#9670;&nbsp;</a></span>mqc_vector_vector_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vector_vector_at </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>)&#160;</td>
          <td class="paramname"><em>Vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in), optional&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Vector_At is a function that returns the vector at the specified subvector of MQC_Vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Vector_At is a function that returns the vector at the specified 
    subvector of MQC_Vector. Negative values of I or J indicate that counting 
    proceeds from the last element rather than the first as with positive numbers.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vec</td><td><pre class="fragment">        Vec is Class(MQC_Vector)
        The MQC_Vector from which the subvector will be extracted.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">        I is Integer(kind=int64)
        The location of the first subvector element in Vec. If I 
        is negative it is counted from the last element of Vec.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td><pre class="fragment">        J is Integer(kind=int64)
        The location of the last subvector element in Vec. If J 
        is negative it is counted from the last element of Vec.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a3b9783636b18868a1a9c6b22a0e057fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9783636b18868a1a9c6b22a0e057fd">&#9670;&nbsp;</a></span>mqc_vector_vector_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine mqc_algebra::mqc_vector_vector_put </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>Vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in), optional&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_Vector_Vector_Put is a subroutine that updates the values of a subvector of a MQC vector with the values of a MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_Vector_Vector_Put is a subroutine that updates the values of a subvector 
    of a MQC vector starting at element I with the values of a MQC vector. Negative 
    I counts from the end of vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Class(MQC_Vector)
        The MQC_Vector to update starting at the Ith element.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VectorIn</td><td><pre class="fragment">        VectorIn is Class(MQC_Vector)
        The subvector with values to insert into Vector. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">        I is Integer(kind=int64)
        The location of the first subvector element in Vector 
        to update. If I is negative it is counted from the last
        element of Vector.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a140f411d3c33c86dbcfe92574e4643f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140f411d3c33c86dbcfe92574e4643f0">&#9670;&nbsp;</a></span>mqc_vectorcomplexdivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorcomplexdivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>compIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorComplexDivide is a function that returns a MQC vector divided by an intrinsic complex scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorComplexDivide is a function that returns a MQC vector divided by an 
    intrinsic complex scalar.  </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to divide.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CompIn</td><td><pre class="fragment">        CompIn is Complex(kind=comp64)
        The intrinsic complex scalar to divide by.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="aa2888851ed72ed54ca69d26140addcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2888851ed72ed54ca69d26140addcc5">&#9670;&nbsp;</a></span>mqc_vectorcomplexproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorcomplexproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>compIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorComplexProduct is a function that returns the product of a <br  />
 MQC vector and an intrinsic complex scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorComplexProduct is a function that returns the product of a MQC vector 
    and an intrinsic complex scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CompIn</td><td><pre class="fragment">        CompIn is Complex(kind=real64)
        The integer complex to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a6fc6130ee8a14a99d0ee7be3460c5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc6130ee8a14a99d0ee7be3460c5bb2">&#9670;&nbsp;</a></span>mqc_vectorintegerdivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorintegerdivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>intIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorIntegerDivide is a function that returns a MQC vector divided by an intrinsic integer scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorIntegerDivide is a function that returns a MQC vector divided by an 
    intrinsic integer scalar.  </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to divide.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The intrinsic integer scalar to divide by.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="aa43354fe746c522e4a4d5dcd3601d298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43354fe746c522e4a4d5dcd3601d298">&#9670;&nbsp;</a></span>mqc_vectorintegerproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorintegerproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>intIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorIntegerProduct is a function that returns the product of a <br  />
 MQC vector and an intrinsic integer scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorIntegerProduct is a function that returns the product of a MQC vector 
    and an intrinsic integer scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IntIn</td><td><pre class="fragment">        IntIn is Integer(kind=int64)
        The integer intrinsic to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a7fb0ed524675a362b716b280e5221a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb0ed524675a362b716b280e5221a40">&#9670;&nbsp;</a></span>mqc_vectormatrixdotproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectormatrixdotproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__matrix.html">mqc_matrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>MB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorMatrixDotProduct is a function that computes the inner product of a MQC vector and a MQC matrix</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorMatrixDotProduct is a function that computes the inner product of 
    a MQC vector and a MQC matrix.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td><pre class="fragment">        VA is Type(MQC_Vector)
        The MQC vector to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MB</td><td><pre class="fragment">        MB is Type(MQC_Matrix)
        The MQC matrix to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="a21d69a7fc334576aed2ba415df7bbc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d69a7fc334576aed2ba415df7bbc81">&#9670;&nbsp;</a></span>mqc_vectorrealdivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorrealdivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>realIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorRealDivide is a function that returns a MQC vector divided by an intrinsic real integer</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorRealDivide is a function that returns a MQC vector divided by an 
    intrinsic real scalar.  </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to divide.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The intrinsic real scalar to divide by.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a0aaa76413201cc25b80779248460873e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aaa76413201cc25b80779248460873e">&#9670;&nbsp;</a></span>mqc_vectorrealproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorrealproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacemqc__algebra_1_1real.html">real</a>(kind=real64), intent(in)&#160;</td>
          <td class="paramname"><em>realIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorRealProduct is a function that returns the product of a <br  />
 MQC vector and an intrinsic real scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorRealProduct is a function that returns the product of a MQC vector 
    and an intrinsic real scalar.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RealIn</td><td><pre class="fragment">        RealIn is Real(kind=real64)
        The real intrinsic to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="aef893bc571f197a714a55d36dba87036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef893bc571f197a714a55d36dba87036">&#9670;&nbsp;</a></span>mqc_vectorscalardivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorscalardivide </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorScalarDivide is a function that returns a MQC vector divided by a MQC scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorScalarDivide is a function that returns a MQC vector divided by a 
    MQC scalar.  </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to divide.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to divide by.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>A. D. Mahler <br  />
 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2019 </dd></dl>

</div>
</div>
<a id="a9b5722ad005cbbf566311c99db1f2dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5722ad005cbbf566311c99db1f2dd8">&#9670;&nbsp;</a></span>mqc_vectorscalarproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorscalarproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>), intent(in)&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorScalarProduct is a function that returns the product of a MQC vector with a MQC scalar</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorScalarProduct is a function that returns the product of a MQC vector 
    with a MQC scalar. </pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td><pre class="fragment">        Vector is Type(MQC_Vector)
        The MQC_Vector to multiply. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Scalar</td><td><pre class="fragment">        Scalar is Type(MQC_Scalar)
        The MQC_Scalar to multiply.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng <br  />
 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
<a id="af43b3db6ebf545d9371912f64cf99121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43b3db6ebf545d9371912f64cf99121">&#9670;&nbsp;</a></span>mqc_vectorvectordifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorvectordifference </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector1In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector2In</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorVectorDifference is a function that subtracts two MQC vectors and stores them in another MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorVectorDifference is a function that subtracts two MQC vectors and 
    stores them in another MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector1In</td><td><pre class="fragment">        Vector1In is Type(MQC_Vector)
        The first MQC vector from which the second will be 
        subtracted.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector2In</td><td><pre class="fragment">        Vector2In is Type(MQC_Vector)
        The second MQC vector that will be subtracted from the
        first.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="acfde21d87680d8d12ea399f5e2f13b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfde21d87680d8d12ea399f5e2f13b7a">&#9670;&nbsp;</a></span>mqc_vectorvectordotproduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__scalar.html">mqc_scalar</a>) function mqc_algebra::mqc_vectorvectordotproduct </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorVectorDotProduct is a function that returns the dot product of two MQC vectors</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorVectorDotProduct is a function that returns the dot product of two 
    MQC vectors. The first vector should be a row vector, while the second vector
    should be a column vector. The vectors should be of the same length.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector1</td><td><pre class="fragment">        Vector1 is Type(MQC_Vector)
        The MQC row vector. </pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector2</td><td><pre class="fragment">        Vector2 is Type(MQC_Vector)
        The MQC column vector. </pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>H. P. Hratchian </dd>
<dd>
L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="af8bfd1876b23289eadd3e0757c3475da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bfd1876b23289eadd3e0757c3475da">&#9670;&nbsp;</a></span>mqc_vectorvectorsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>) function mqc_algebra::mqc_vectorvectorsum </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector1In</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structmqc__algebra_1_1mqc__vector.html">mqc_vector</a>), intent(in)&#160;</td>
          <td class="paramname"><em>Vector2In</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> MQC_VectorVectorSum is a function that adds two MQC vectors and stores them in another MQC vector</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    MQC_VectorVectorSum is a function that adds two MQC vectors and stores them in
    another MQC vector.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector1In</td><td><pre class="fragment">        Vector1In is Type(MQC_Vector)
        The first MQC vector that will be summed.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector2In</td><td><pre class="fragment">        Vector2In is Type(MQC_Vector)
        The second MQC vector that will be summed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>

</div>
</div>
<a id="af62b00883eb990030317e03cc38e4c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62b00883eb990030317e03cc38e4c44">&#9670;&nbsp;</a></span>symindexhash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind=int64) function mqc_algebra::symindexhash </td>
          <td>(</td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in)&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in), optional&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind=int64), intent(in), optional&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> SymIndexHash is a function that returns the index in a vector of a symmetric-packed matrix or rank-4 tensor</b> </p>
<dl class="section user"><dt>Purpose:</dt><dd><pre class="fragment">    SymIndexHash is a function that returns the index in a vector of a symmetric-
    packed matrix or rank-4 tensor. If a matrix is tested, it is assumed lower-
    triangular row-wise stored.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td><pre class="fragment">        I is integer(kind=int64)
        The first index of the matrix/rank-4 tensor.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td><pre class="fragment">        I is integer(kind=int64)
        The second index of the matrix/rank-4 tensor.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td><pre class="fragment">        K is integer(kind=int64),Optional
        The third index of the rank-4 tensor. This argument is
        only required when taking hash of a rank-4 tensor.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td><pre class="fragment">        L is integer(kind=int64),Optional
        The fourth index of the rank-4 tensor. This argument is
        only required when taking hash of a rank-4 tensor.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>X. Sheng </dd>
<dd>
L. M. Thompson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemqc__algebra.html">mqc_algebra</a></li>
    <li class="footer">Generated on Sat Oct 12 2019 10:03:17 for MQCPack by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
